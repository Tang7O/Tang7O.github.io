<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tang7O&#39;S BLOG</title>
  
  
  <link href="https://tang7o.cn/atom.xml" rel="self"/>
  
  <link href="https://tang7o.cn/"/>
  <updated>2022-04-13T13:31:49.208Z</updated>
  <id>https://tang7o.cn/</id>
  
  <author>
    <name>Tang7O</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>进程切换为什么比线程切换开销大</title>
    <link href="https://tang7o.cn/2022/03/22/%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2/"/>
    <id>https://tang7o.cn/2022/03/22/%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2/</id>
    <published>2022-03-22T02:21:47.000Z</published>
    <updated>2022-04-13T13:31:49.208Z</updated>
    
    <content type="html"><![CDATA[<p>进程切换比线程切换开销大是因为进程切换时要切页表，而且往往伴随着页调度，因为进程的数据段代码段要换出去，以便把将要执行的进程的内容换进来。本来进程的内容就是线程的超集。而且线程只需要保存线程的上下文（相关寄存器状态和栈的信息）就好了，动作很小。</p><p>但是如果是不同进程内的线程互换就不好说了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;进程切换比线程切换开销大是因为进程切换时要切页表，而且往往伴随着页调度，因为进程的数据段代码段要换出去，以便把将要执行的进程的内容换进来。本来进程的内容就是线程的超集。而且线程只需要保存线程的上下文（相关寄存器状态和栈的信息）就好了，动作很小。&lt;/p&gt;
&lt;p&gt;但是如果是不同</summary>
      
    
    
    
    <category term="OS" scheme="https://tang7o.cn/categories/OS/"/>
    
    
    <category term="OS" scheme="https://tang7o.cn/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>MySQL Limit优化</title>
    <link href="https://tang7o.cn/2022/03/16/MySQL-LIMIT/"/>
    <id>https://tang7o.cn/2022/03/16/MySQL-LIMIT/</id>
    <published>2022-03-16T12:44:13.000Z</published>
    <updated>2022-04-13T13:31:48.203Z</updated>
    
    <content type="html"><![CDATA[<h2 id="耗时本质"><a href="#耗时本质" class="headerlink" title="耗时本质"></a>耗时本质</h2><p>mysql大数据量使用limit分页，随着页码的增大，查询效率越低下。</p><p>当一个表有几百万的数据的时候成了问题！</p><p>如 <code>select * from table limit 0,10</code> 这个没有问题，当 <code>limit 100000,10</code> 的时候就很慢。</p><p>原因本质：</p><ol><li>limit 语句的查询时间和其实记录（offset）的大小成正比。</li><li>mysql 的 limit 语句是很方便，但是对于记录很多：百万，千万级别的表并不适合直接使用。</li></ol><p>例如： <code>limit 10000,20</code> 的意思扫描满足条件的 10020 行，扔掉 前面的 10000 行，返回最后的 20 行，问题就在这里。<code>limit 2000000，30</code> 扫描了 2000030 行，慢的都堵死了，甚至会导致磁盘 IO 100%消耗，但是 <code>limit 30</code> 这样的语句才扫描 30 行。</p><h2 id="优化手段"><a href="#优化手段" class="headerlink" title="优化手段"></a>优化手段</h2><p>去掉或者利用 <code>limit offset,size</code> 中的 offset。</p><p>不是直接使用limit，而是首先获取到 offset 的 id 然后再使用 limit size 来获取数据。</p><h2 id="对-limit-分页问题的性能优化方法"><a href="#对-limit-分页问题的性能优化方法" class="headerlink" title="对 limit 分页问题的性能优化方法"></a>对 limit 分页问题的性能优化方法</h2><p>如果数据是连续不中断的可以使用 <code>between and</code> 来代替 limit 查询。</p><h3 id="利用表的覆盖索引来加速分页查询"><a href="#利用表的覆盖索引来加速分页查询" class="headerlink" title="利用表的覆盖索引来加速分页查询"></a>利用表的覆盖索引来加速分页查询</h3><p>覆盖索引：</p><p>就是 select 的数据列只从索引中就能获得，不必读取数据行。也就是说：<strong>查询列要被所创建的索引覆盖</strong>。</p><p>因为利用索引查找有优化算法，且数据就在查询索引上面，不用再去找相关的数据地址了，这样节省了很多时间。另外 mysql 中也有相关的索引缓存，在并发高的时候利用缓存就效果更好了。在我们的例子中，我们知道 id 字段是主键，自然就包含了默认的主键索引。</p><p>这次我们之间查询最后一页的数据（利用覆盖索引，只包含id列），如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#覆盖索引只包含id列 的时间显著优于 select * 不言而喻</span><br><span class="line">select * from order_table where company_id = 1 and mark =0 order by id desc limit 200000 ,20;</span><br><span class="line">select id from order_table where company_id = 1 and mark =0 order by id desc limit 200000 ,20;</span><br></pre></td></tr></table></figure><p>如果我们要查询所有列，有两种方法，一种是 id&gt;= 的形式，另一种就是利用 join：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#两者用的都是一个原理嘛，所以效果也差不多</span><br><span class="line">SELECT * FROM xxx WHERE ID &gt; =(select id from xxx limit 1000000, 1) order by id limit 20;</span><br><span class="line">SELECT * FROM xxx a JOIN (select id from xxx limit 1000000, 20) b ON a.ID = b.id;</span><br></pre></td></tr></table></figure><p>上述子查询的方式虽然比直接使用 Limit 要快很多，但是当数据量过大（千万级别）时，子查询需要很长时间，依旧不够快。</p><h3 id="去掉子查询"><a href="#去掉子查询" class="headerlink" title="去掉子查询"></a>去掉子查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#仅仅使用 id&lt;max and limit size;</span><br><span class="line">#每次查询前获取上一页最小id作为下一页的最大id使用 假设为：800000001</span><br><span class="line">#首页查询</span><br><span class="line">select * from order_table where company_id = 1 and mark =0 order by id desc limit 200000;</span><br><span class="line">#非首页查询  </span><br><span class="line">select * from order_table where company_id = 1 and mark =0 and id &lt; 800000001 order by id desc limit 200000;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;耗时本质&quot;&gt;&lt;a href=&quot;#耗时本质&quot; class=&quot;headerlink&quot; title=&quot;耗时本质&quot;&gt;&lt;/a&gt;耗时本质&lt;/h2&gt;&lt;p&gt;mysql大数据量使用limit分页，随着页码的增大，查询效率越低下。&lt;/p&gt;
&lt;p&gt;当一个表有几百万的数据的时候成了问题！</summary>
      
    
    
    
    <category term="MySQL" scheme="https://tang7o.cn/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://tang7o.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 1.0 VS HTTP 1.1</title>
    <link href="https://tang7o.cn/2022/03/08/HTTP1-0-1-1/"/>
    <id>https://tang7o.cn/2022/03/08/HTTP1-0-1-1/</id>
    <published>2022-03-08T07:43:49.000Z</published>
    <updated>2022-04-13T13:31:48.011Z</updated>
    
    <content type="html"><![CDATA[<p>本文将从以下几个维度来对比 HTTP1.0 和 HTTP1.1:</p><ul><li>响应状态码</li><li>缓存处理</li><li>连接方式</li><li>Host 头处理</li><li>带宽优化</li></ul><h2 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h2><p>HTTP/1.0 仅定义了 16 种状态码。HTTP/1.1 中新加入了大量的状态码，光是错误响应码就新增了 24 种。比如说：</p><ul><li><code>100（Continue）</code>：在请求大资源前的预热请求。</li><li><code>206（Partial Content）</code>：范围请求的标识码。</li><li><code>409（Conflict）</code>：请求与当前资源的规定冲突。</li><li><code>410（Gone）</code>：资源已被永久转移，而且没有任何已知的转发地址。</li></ul><h2 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h2><p>缓存技术通过避免用户与源服务器的频繁交互，节约了大量的网络带宽，降低了用户接收信息的延迟。</p><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3><p>HTTP/1.0 提供的缓存机制非常简单。服务器端使用 <code>Expires</code> 标签来标志（时间）一个响应体，在 <code>Expires</code> 标志时间内的请求，都会获得该响应体缓存。服务器端在初次返回给客户端的响应体中，有一个 <code>Last-Modified</code> 标签，该标签标记了被请求资源在服务器的最后一次修改。在请求头中，使用 <code>If-Modifiend-Since</code> 标签，该标签标志一个时间，意为客户端向服务器进行问询：”该时间之前，我要请求的资源是否有被修改过？“通常情况下，请求头中的 <code>If-Modifiend-Sine</code> 的值即为上一次获得该资源时，响应体中的 <code>Last-Modified</code> 的值。</p><p>如果服务器即收到了请求头，并判断 <code>If-Modifiend-Sine</code> 时间后，资源确实没有被修改过，则返回给客户端一个 <code>304 not modified</code> 响应头，表示”缓存可用，你从浏览器里拿吧！“。</p><p>如果判断 <code>If-Modifiend-Sine</code> 时间后，资源被修改过，则返回给客户端一个 <code>200 OK</code> 的响应体，并附带全新的资源内容，表示”资源被修改过了，我给你一份新的“。</p><p><img src="1.png" class="lazyload" data-srcset="1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p><img src="2.png" class="lazyload" data-srcset="2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><p>HTTP/1.1 的缓存机制在 HTTP/1.0 的基础上，大大增加了灵活性和扩展性。基本工作原理和 HTTP/1.0 保存不变，而是增加了更多细致的特性。其中，请求头中最常见的特性就是 <code>Cache-Control</code>，详见 MDN Web 文档 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">Cache-Control</a></p><h2 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h2><p><strong>HTTP/1.0 默认使用短链接</strong>，也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或者其他的类型的 Web 页中包含有其他 Web 资源（如 JavaScript 文件、图像文件、CSS 文件）等，每遇到这样的一个 Web 资源，浏览器就会重新建立一个 TCP 连接，这样就会导致有大量的“握手报文”和“挥手报文”占用了带宽。</p><p><strong>为了解决 HTTP/1.0 存在的资源浪费问题，HTTP/1.1 优化为默认长连接模式。</strong>采用长连接模式的请求报文会通知服务端：“我会向你请求连接，并且连接成功建立后，请不要关闭”。因此，该 TCP 连接将持续打开，为后续的客户端服务端的数据交互服务。也就是说在使用长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。</p><p>如果 TCP 连接一直保持的话也是对资源的浪费，因此，一些服务器软件还会支持超时时间的时间。在超时时间之内没有新的请求达到，TCP 连接才会被关闭。</p><p>有必要说明的是，HTTP/1.0 仍提供了长连接选项，在请求头中加入 <code>Connection: Keep-alive</code>。同样的，在HTTP/1.1中，如果不希望使用长连接选项，也可以在请求头中加入 <code>Connection: close</code>，这样会通知服务器端：“我不需要长连接，连接成功后即可关闭”。</p><p><strong>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</strong></p><p><strong>实现长连接需要客户端和服务端都支持长连接。</strong></p><h2 id="Host-头处理"><a href="#Host-头处理" class="headerlink" title="Host 头处理"></a>Host 头处理</h2><p>域名系统（DNS）允许多个主机名绑定到同一个 IP 地址上，但是 HTTP/1.0 并没有考虑这个问题，假设我们有一个资源 URL 是 <code>http://tang7o.cn/index.html</code>, HTTP/1.0 的请求报文中，将会请求的是 <code>GET /index.html HTTP/1.0</code> 也就是不会加入主机名。这样的报文发送到服务器端，服务端理解不了客户端想请求的真正网址。</p><p>因此，HTTP/1.1 在请求头中加入了 <code>Host</code> 字段。加入 <code>Host</code> 字段的报文头部将会是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: tang7o.cn</span><br></pre></td></tr></table></figure><p>这样，服务器就可以确定客户端想要请求的真正网址了。</p><h2 id="带宽优化"><a href="#带宽优化" class="headerlink" title="带宽优化"></a>带宽优化</h2><h3 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h3><p>HTTP/1.1 引入了范围请求（range request）机制，以避免带宽的浪费。当客户端想请求一个文件的一部分，或者需要继续下载一个已经下载了部分但被终止的文件，HTTP/1.1 可以在请求中加入 <code>Range</code> 头部，以请求（并只能请求字节型数据）数据的一部分。服务器可以忽略 <code>Range</code> 头部，也可以返回若干 <code>Range</code> 响应。</p><p>如果一个响应包括部分数据的话，那么将带有 <code>206（Partial Content）</code>状态码。该状态码的意义在于避免了 HTTP/1.0 代理缓存错误的把该响应认为是一个完整的数据响应，从而把他当作一个请求的响应缓存。</p><p>在范围响应中，<code>Content-Range</code> 头部标志指示出了该数据块的偏移量和数据块长度。</p><h3 id="状态码100"><a href="#状态码100" class="headerlink" title="状态码100"></a>状态码100</h3><p>HTTP/1.0 中新加入了状态码 <code>100</code>。该状态码的使用场景为，存在某些较大的文件请求，服务器可能不愿意响应这种请求，此时状态码 <code>100</code> 可以作为指示请求是否被正常响应。</p><p><img src="3.png" class="lazyload" data-srcset="3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p><img src="4.png" class="lazyload" data-srcset="4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>然而在 HTTP/1.0 中没有 <code>100（Continue）</code> 状态码，要想触发这一机制，可以发送一个 <code>Expect</code> 头部，其中包含一个 <code>100-continue</code> 的值。</p><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>许多格式的数据在传输时都会做压缩处理。数据的压缩可以大幅优化带宽的利用。然而，HTTP/1.0 对数据压缩的选项提供的不多，不支持压缩细节的选择，也无法区分端到端压缩或者是逐跳压缩。</p><p>HTTP/1.1 则对内容编码和传输编码做了区分，内容编码总是端到端的，传输编码总是逐跳的。</p><p>HTTP/1.0 包含了 <code>Content-Encoding</code> 头部，对消息进行端到端编码。HTTP/1.1 加入了 <code>Transfer-Encoding</code> 头部可以对消息进行逐跳传输编码。HTTP/1.1 还加入了 <code>Accept-Encoding</code> 头部，是客户端来指示它能处理什么样的内容编码。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><strong>连接方式</strong>：HTTP/1.0 默认短链接，HTTP/1.1 默认长连接。</li><li><strong>状态响应码</strong>：HTTP/1.1 中新家了大量的状态码，光是错误响应状态码就新增了 24 种。</li><li><strong>缓存处理</strong>：在 HTTP/1.0 中主要使用 header 里面的 <code>If-Modified-Since, Expires</code> 来作为缓存判断的标准，HTTP/1.1 则引入了更多的缓存控制策略，例如 <code>Entity tag, If-Unmodified-Since, If-Match, If-None-Match</code> 等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong>： HTTP/1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP/1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 <code>206（Partial Content）</code>，这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>Host 头处理</strong>：HTTP/1.1 在请求头中加入了 <code>Host</code> 字段。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文将从以下几个维度来对比 HTTP1.0 和 HTTP1.1:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;响应状态码&lt;/li&gt;
&lt;li&gt;缓存处理&lt;/li&gt;
&lt;li&gt;连接方式&lt;/li&gt;
&lt;li&gt;Host 头处理&lt;/li&gt;
&lt;li&gt;带宽优化&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;响应状态码&quot;</summary>
      
    
    
    
    <category term="网络" scheme="https://tang7o.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="HTTP" scheme="https://tang7o.cn/categories/%E7%BD%91%E7%BB%9C/HTTP/"/>
    
    
    <category term="网络" scheme="https://tang7o.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="HTTP" scheme="https://tang7o.cn/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Redis的缓存问题</title>
    <link href="https://tang7o.cn/2022/03/07/Redis%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/"/>
    <id>https://tang7o.cn/2022/03/07/Redis%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/</id>
    <published>2022-03-07T03:09:14.000Z</published>
    <updated>2022-04-13T13:31:48.339Z</updated>
    
    <content type="html"><![CDATA[<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指在某一个时刻出现大规模的缓存失效的情况，大量的请求直接打在数据库上面，可能会导致数据库宕机，如果这时候重启数据库并不能解决根本问题，会再次造成缓存雪崩。</p><h4 id="为什么会造成缓存雪崩？"><a href="#为什么会造成缓存雪崩？" class="headerlink" title="为什么会造成缓存雪崩？"></a>为什么会造成缓存雪崩？</h4><p>一般来说，造成缓存雪崩主要有两种可能</p><ul><li>Redis 宕机了</li><li>很多 key 采取了相同的过期时间</li></ul><h4 id="如何解决缓存雪崩？"><a href="#如何解决缓存雪崩？" class="headerlink" title="如何解决缓存雪崩？"></a>如何解决缓存雪崩？</h4><ul><li>为避免 Redis 宕机造成缓存雪崩，可以搭建 Redis 集群。</li><li>尽量不要设置相同的过期时间，可以在原有的过期时间加上随机数。</li><li>服务降级，当流量达到一定的阈值时，就直接返回“系统繁忙”之类的提示，防止过多的请求直接打在数据库上，这样虽然难用，但是至少可以避免服务器宕机。</li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存雪崩是大规模的 key 失效，而缓存击穿是一个热点的 key，有大量并发集中对其访问，突然间这个 key 失效了，导致大量并发请求全部打在数据库上， 导致数据库压力剧增，这种现象就叫做缓存击穿。</p><p>比较经典的例子就是商品秒杀时，大量的用户在抢某个商品时，商品的 key 突然过期失效了，所有请求都到数据库上了。</p><h4 id="如何解决缓存击穿？"><a href="#如何解决缓存击穿？" class="headerlink" title="如何解决缓存击穿？"></a>如何解决缓存击穿？</h4><ul><li>热点 key 不设置过期时间，避免 key 过期失效。</li><li>加锁，如果缓存失效的情况，只有拿到锁才能查询数据库，降低了在同一时刻打在数据库上的请求，防止数据库宕机，不过这样会导致系统的性能变差。</li></ul><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指用户的请求没有经过缓存而直接请求到数据库上了，比如用户请求的 key 在 Redis 中不存在，或者用户恶意伪造大量不存在的 key 进行请求，都可以绕过缓存，导致数据库压力太大宕机。</p><h4 id="如何解决缓存穿透？"><a href="#如何解决缓存穿透？" class="headerlink" title="如何解决缓存穿透？"></a>如何解决缓存穿透？</h4><ul><li>参数校验，例如可以对用户 id 进行校验，直接拦截不合法的请求。</li><li>缓存空值，如果某个 key 在 Redis 中不存在，在数据库中也不存在，则把这个 key 值保存到 Redis，设置 value = “null”。</li><li>布隆过滤器，布隆过滤器可以判断这个 key 在不在数据库中，特点是：如果判断这个 key 不在数据库，那么这个 key 一定不在数据库中，如果判断这个 key 在数据库中，也不能保证这个 key 一定在数据库中。就是会有少数漏网之鱼，造成这种现象的原因是因为布隆过滤器使用了 hash 算法，对 key 进行 hash 时，不同的 key 的 hash 值一定不同，但是相同的 hash 值不能说明这两个 key 相同。</li></ul>]]></content>
    
    
    <summary type="html">什么是缓存雪崩、缓存穿透、缓存击穿，以及它们的解决方案</summary>
    
    
    
    <category term="Redis" scheme="https://tang7o.cn/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://tang7o.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis并发竞争 key 问题</title>
    <link href="https://tang7o.cn/2022/03/07/Redis%E5%B9%B6%E5%8F%91/"/>
    <id>https://tang7o.cn/2022/03/07/Redis%E5%B9%B6%E5%8F%91/</id>
    <published>2022-03-07T02:16:51.000Z</published>
    <updated>2022-04-13T13:31:48.325Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 并发竞争 key 就是多个客户端操作一个 key，可能会导致数据出现问题，主要有以下几种解决方法：</p><ul><li>乐观锁，<code>watch</code> 命令可以方便的实现乐观锁。<code>watch</code> 命令会监视给的的每一个 key，当 <code>exec</code> 时如果监视的任一个 key 自从调用 <code>watch</code> 后发生过变化，则整个事务会回滚，不执行任何动作。不能在分片集群中使用。</li><li>分布式锁，适合分布式场景</li><li>时间戳，适合有序场景，比如 A 想把 key 设置为 1，B 想把 key 设置为 2，C 想把 key 设置为 3，对每个操作加上时间戳，写入前先比较自己的时间戳是不是早于现有记录的时间戳，如果早于，就不写入了。</li><li>消息队列，串行化处理。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis 并发竞争 key 就是多个客户端操作一个 key，可能会导致数据出现问题，主要有以下几种解决方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;乐观锁，&lt;code&gt;watch&lt;/code&gt; 命令可以方便的实现乐观锁。&lt;code&gt;watch&lt;/code&gt; 命令会监视给的的每一个 k</summary>
      
    
    
    
    <category term="Redis" scheme="https://tang7o.cn/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://tang7o.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis分布式锁</title>
    <link href="https://tang7o.cn/2022/03/04/Redis%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <id>https://tang7o.cn/2022/03/04/Redis%E5%88%86%E5%B8%83%E5%BC%8F/</id>
    <published>2022-03-04T01:56:34.000Z</published>
    <updated>2022-04-13T13:31:48.296Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是分布式锁？"><a href="#什么是分布式锁？" class="headerlink" title="什么是分布式锁？"></a>什么是分布式锁？</h3><p>分布式锁就是为了保证在分布式场景下，共享资源在同一时刻只能被一个线程访问，或者说是用来控制分布式系统之间同步访问共享资源。</p><h3 id="分布式锁有什么特性？"><a href="#分布式锁有什么特性？" class="headerlink" title="分布式锁有什么特性？"></a>分布式锁有什么特性？</h3><ul><li>互斥性：在任意时刻，同一条数据只能被一台机器的一个线程访问。</li><li>高可用性：当部分节点宕机后，客户端仍可以正常的获取锁和释放锁。</li><li>独占性：加锁和释放锁必须在同一台服务器执行，不能在一个服务器上获取锁，在另一个服务器释放锁。</li><li>防锁超时：如果客户端没有主动释放锁，服务器会在一定时间后自动释放锁，防止客户端宕机或者网络异常导致宕机。</li></ul><h3 id="分布式锁的实现方法？"><a href="#分布式锁的实现方法？" class="headerlink" title="分布式锁的实现方法？"></a>分布式锁的实现方法？</h3><p>基本思路就是要在整个系统中提供一个全局、唯一的“锁”，每个系统需要加锁时，都去尝试获取这个“锁”。</p><h3 id="Redis-如何实现分布式锁"><a href="#Redis-如何实现分布式锁" class="headerlink" title="Redis 如何实现分布式锁"></a>Redis 如何实现分布式锁</h3><p>前面写了分布式锁的特性，其实实现分布式锁就是围绕这些特性展开的。</p><p>Redis 实现分布式锁的主要命令：<strong>SETNX</strong>，该命令的作用是当 key 不存在时设置 key 的值，当 key 存在时，什么都不做。</p><p>先来看最简单的实现方式，如下图：</p><p><img src="1.png" class="lazyload" data-srcset="1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>从上图可以看到主要两个关系步骤，加锁和解锁。</p><p>但是这个简陋的分布式锁存在很多问题，并不难满足上述介绍的分布式锁的特性，比如，当线程1执行到上图中执行业务这步时，业务代码突然出现了异常，无法进行删除锁这一步，那就G了，死锁了，其它线程也无法获取到锁了（SETNX 特性）。</p><h4 id="改进方案-1"><a href="#改进方案-1" class="headerlink" title="改进方案 1"></a>改进方案 1</h4><p>一提到异常，有人就想到了 <code>try-catch-finally</code> 了，把删除锁的操作放到 finally 代码块中，就算出现异常，也是能够正常释放锁的，执行业务出现异常这个问题解决了。但是这并不靠谱，如果 Redis 在执行业务这步宕机了呢，finally 代码块也不会执行。</p><h4 id="改进方案-2"><a href="#改进方案-2" class="headerlink" title="改进方案 2"></a>改进方案 2</h4><p>其实这个问题也好解决，只需要给锁设置一个过期时间就可以，对 key 设置过期时间在 Redis 中是常规操作了。<code>SET key value [EX seconds][PX milliseconds] [NX|XX]</code></p><ul><li>EX second: 设置键的过期时间为second秒；</li><li>PX millisecond：设置键的过期时间为millisecond毫秒；</li><li>NX：只在键不存在时，才对键进行设置操作；</li><li>XX：只在键已经存在时，才对键进行设置操作；</li><li>SET操作完成时，返回OK，否则返回nil。</li></ul><p>那现在这个方案就没问题了吗？显然没有</p><p>例如，线程 1 获取了锁，并设置了有效时间 10 秒，但是线程 1 在执行业务时超过了 10 秒，锁到期自动释放了，在释放后，线程 2 又获取了锁，在线程 2 执行业务时，线程 1 执行完业务了，随后执行了删除锁这一步，但是线程 1 的锁自动释放了，它删除的是线程 2 的锁。</p><h4 id="改进方案-3"><a href="#改进方案-3" class="headerlink" title="改进方案 3"></a>改进方案 3</h4><p>其实看起来方案 2 的问题很容易解决，只要把锁的过期时间设置的很长，就可以避免两个问题，但是这样并不可行，因为这样相当于回到最简陋的方案（会导致线程 2 一直获取不到锁（线程 1 因异常未能删除锁的情况下））。</p><p>如何解决线程 1 释放线程 2 的锁这一问题？</p><p>很简单，可以为锁加一个标识，例如生成一个 UUID，作为锁的标识，每个线程获取锁时都会生成一个不同的 UUID 作为标识，在删除锁时会进行判断，锁的标识和自己生成 UUID 相同时才能进行删除操作。</p><p>那么如何确定锁的过期时间呢？</p><p>可以在加锁时，设置一个预估的过期时间，然后开启一个守护线程，定时检测这个锁的失效时间，如果快要过期了，操作还未完成，那么就自动对锁进行“续费”。</p><p>那方案 3 就没有问题了吗？并不是，比如方案 3 的分布式锁还不具备可重入性（同一线程可以重复获取锁，解决线程需要多次进入锁内部执行任务的问题）</p><h4 id="改进方案-4"><a href="#改进方案-4" class="headerlink" title="改进方案 4"></a>改进方案 4</h4><p>参考其他重入锁的设计，通过对锁进行重入计数，加锁时加 1，解锁时减 1，计数为 0 时才能释放锁。</p><p>那现在的方案还有问题吗？其实还有，比如，线程 1 获取了锁，线程 2 没能获取到锁，那么线程 2 怎么知道线程 1 什么时候释放了锁，进而再去获取锁呢？</p><h4 id="改进方案-5"><a href="#改进方案-5" class="headerlink" title="改进方案 5"></a>改进方案 5</h4><p>方案 4 中问题，一般有两种解决方案：</p><ul><li>可以通过客户端轮询的方式，就是线程 2 过一会就过来看看是不是能获取锁了。这种方案比较消耗服务器资源，当并发量比较大时，会影响服务器的效率。</li><li>通过 Redis 的发布订阅功能，当获取锁失败时，订阅锁信息，获取锁成功后释放时，发布释放锁信息。</li></ul><p>现在这个方案完美了吗？没有</p><p>目前讨论的都是单节点的情况，如果这个节点挂了，那么所有的客户端都获取不到锁了。</p><h4 id="改进方案-6"><a href="#改进方案-6" class="headerlink" title="改进方案 6"></a>改进方案 6</h4><p>为了实现 Redis 的分布式锁，Redis 的作者提出了 <a href="https://redis.io/topics/distlock">RedLock 算法</a>(英文好的可以直接去官网查看)。</p><p>首先介绍保证分布式锁的有效性和安全性的要求：</p><ul><li>互斥性：在任何给定时刻，只有一个客户端可以持有一个锁。</li><li>释放死锁：获取锁的客户端崩溃或者被分区，也可以释放锁。</li><li>容错性：只要大多 Redis 节点都在运行，客户端就能获取和释放锁。</li></ul><p>为什么基于故障转移实现的 Redis 分布式锁还不够用?</p><p>官网中举了一个例子：</p><p>客户端A获得主服务器上的锁，然后主服务器向从服务器复制数据的过程中崩了，导致数据没有复制到从数据库中，这时会在从服务器中选出来一个升级为主服务器，但新的主服务器中并没有客户端A设置的锁。所以客户端B也可以获取到锁，违背了上面说的<strong>互斥性</strong>。</p><p>这就解释了为什么使用 RedLock 算法。</p><h3 id="RedLock-算法"><a href="#RedLock-算法" class="headerlink" title="RedLock 算法"></a>RedLock 算法</h3><p>假设有 5 个完全独立的 Redis 服务器，多节点 Redis 实现的 RedLock 算法如下：</p><ul><li>获取当前时间戳。</li><li>客户端尝试在 5 个实例中按顺序获取锁，在所有实例中使用相同的键名和随机值。当在每个实例中设置锁时，需要将锁的获取时间设置的比锁过期时间短很多。例如，如果锁自动释放时间为 10 秒，则锁的获取时间在 5-50 毫秒。这是为了不要过长时间等待已经关闭的 Redis 实例，如果一个 Redis 实例不可用，我们应该尽快尝试下一个 Redis 实例。</li><li>客户端通过从当前时间中减去步骤 1 中获取的时间戳，计算出获取锁所需的时间。当且仅当客户端能够在大多数实例（本例至少 3 个）中获取锁，并且化费在获取锁的总时间小于锁的有效性时间，该锁则被认为已经获得。</li><li>如果获得了锁，锁真正的有效时间为锁初始设置的有效时间（过期时间）减去步骤 3 的时间，例如：锁初始的有效时间为 5s，获取锁花了 0.5s，则锁真正的有效时间为 4.5s（忽略了时钟偏移，时钟偏移指两个电脑间时间流速基本相同的情况下，两个电脑（或两个进程）时间的差值）</li><li>如果客户端由于某些原因无法获取锁（要么无法锁定 N/2 + 1 个 Redis 实例，要么锁的有效时间为负数），客户端将尝试解锁所有的 Redis 实例（即时是它认为无法锁定的 Redis 实例）</li></ul><h4 id="RedLock-算法是异步的吗？"><a href="#RedLock-算法是异步的吗？" class="headerlink" title="RedLock 算法是异步的吗？"></a>RedLock 算法是异步的吗？</h4><p>可以看成同步算法，虽然没有跨进程的同步时钟，但每个进程（多个电脑）的本地时间仍然大致以相同的速度流动，与锁的自动释放时间相比，误差较小，将其忽略的话，则可以看成同步算法。</p><h4 id="RedLock-失败重试"><a href="#RedLock-失败重试" class="headerlink" title="RedLock 失败重试"></a>RedLock 失败重试</h4><p>当客户端无法获取到锁时，应该在随机时间后重试，并且理想的客户端应该并发地将命令同时发给所有 Redis 实例。对于已经获取锁的客户端要在完成任务后及时释放锁，这样其他客户端就不需要等锁自动过期后再获取。如果在获取锁后，在主动释放锁前无法连接到 Redis 实例，那就只能等待锁自动失效了。</p><h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><p>释放锁很简单，只要释放所有 Redis 实例中的锁，不需要考虑是否释放成功（释放时需要判断这个锁的 vlaue 值是否自己设置的，避免释放其他客户端设置的锁）</p><h4 id="RedLock的-Safety-arguments"><a href="#RedLock的-Safety-arguments" class="headerlink" title="RedLock的 Safety arguments"></a>RedLock的 Safety arguments</h4><ul><li>假设客户端可以获取到大多数 Redis 实例，并且所有 Redis 实例具有相同的 key 和过期时间，但不同的 Redis 实例的 key 是不同的时间设置的（获取锁的时间不可能完全一致），所以过期时间也不同，假设获取第一个 Redis 实例的锁的时间为 T1,最后一个为 T2，则客户端获得锁的最小有效时间为 key 的有效时间 -（T2-T1）-时钟漂移。</li><li>为什么需要获取一半以上的 Redis 实例的锁才算获取到锁成功呢？因为如果获取不到一半也算成功的话会导致多个客户端同时获取到锁，违背了互斥性。</li><li>一个客户端锁定大多数 Redis 实例所需的时间大于或者接近锁的过期时间时，会认为锁无效，并解锁所有 Redis 实例。</li></ul><h4 id="RedLock崩溃的相关解决方法"><a href="#RedLock崩溃的相关解决方法" class="headerlink" title="RedLock崩溃的相关解决方法"></a>RedLock崩溃的相关解决方法</h4><p>场景：客户端 A 在成功获取锁后，如果所有 Redis 重启，这时客户端 B 就可以再次获取到锁，违背了互斥性。</p><p>解决方法：开启 AOF 持久化，可以解决这个问题，但是 AOF 同步到磁盘上的方式默认是每秒一次，如果 1 秒内断电，会导致 1 秒内的数据丢失，如果客户端是在这 1 秒内获得的锁，立即重启可能会导致锁的互斥性失效，解决方法是每次 Redis 无论因为什么原因停掉都要等 key 的过期时间到了再重启（延迟重启），这么做的缺点就是在等待重启这段时间内 Redis 处于关闭的状态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是分布式锁？&quot;&gt;&lt;a href=&quot;#什么是分布式锁？&quot; class=&quot;headerlink&quot; title=&quot;什么是分布式锁？&quot;&gt;&lt;/a&gt;什么是分布式锁？&lt;/h3&gt;&lt;p&gt;分布式锁就是为了保证在分布式场景下，共享资源在同一时刻只能被一个线程访问，或者说是用来控制分</summary>
      
    
    
    
    <category term="Redis" scheme="https://tang7o.cn/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://tang7o.cn/tags/Redis/"/>
    
    <category term="分布式" scheme="https://tang7o.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>服务器关闭,客户端继续写会发生什么？</title>
    <link href="https://tang7o.cn/2022/03/01/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%B3%E9%97%AD-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BB%A7%E7%BB%AD%E5%86%99%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>https://tang7o.cn/2022/03/01/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%B3%E9%97%AD-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BB%A7%E7%BB%AD%E5%86%99%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2022-03-01T02:44:44.000Z</published>
    <updated>2022-04-13T13:31:49.038Z</updated>
    
    <content type="html"><![CDATA[<p>当服务器进程被终止时，会关闭其打开的所有文件描述符，此时就会向客户端发送一个 FIN 的报文,客户端则响应一个 ACK 报文,但是这样只完成了“四次挥手”的前两次挥手，也就是说这样只实现了半关闭，客户端仍然可以向服务器写入数据。</p><p>但是当客户端向服务器写入数据时，由于服务器端的套接字进程已经终止，此时连接的状态已经异常了，所以服务端进程不会向客户端发送 ACK  报文，而是发送了一个 RST 报文请求将处于异常状态的连接复位；如果客户端还要继续向服务端发送数据，系统会发出一个 SIGPIPE 信号给进程，告诉进程这个连接已经断开了，不要再写了。</p><p>根据信号的默认处理规则 SIGPIPE 信号的默认执行动作是 terminate(终止、退出),所以客户端会退出。</p>]]></content>
    
    
    <summary type="html">服务器关闭，客户端继续发送报文，会发生什么呢？</summary>
    
    
    
    <category term="网络" scheme="https://tang7o.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="TCP" scheme="https://tang7o.cn/categories/%E7%BD%91%E7%BB%9C/TCP/"/>
    
    
    <category term="网络" scheme="https://tang7o.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="TCP" scheme="https://tang7o.cn/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>HashMap为什么使用红黑叔而不是其他数据结构</title>
    <link href="https://tang7o.cn/2022/03/01/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E8%80%8C%E4%B8%8D%E6%98%AF%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://tang7o.cn/2022/03/01/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E8%80%8C%E4%B8%8D%E6%98%AF%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-03-01T01:22:09.000Z</published>
    <updated>2022-04-13T13:31:48.024Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么要使用红黑树以及什么时候使用红黑树？"><a href="#为什么要使用红黑树以及什么时候使用红黑树？" class="headerlink" title="为什么要使用红黑树以及什么时候使用红黑树？"></a>为什么要使用红黑树以及什么时候使用红黑树？</h3><p>向 HashMap 中添加数据时不可避免的会产生 Hash 冲突，而 HashMap 使用拉链法来解决 Hash 冲突，这就导致在 Hash 冲突较多的时候，会严重影响 HashMap 的查询效率（链表查询时间复杂度为O(n))，因此引入了红黑树（查询时间复杂度O(log n))这一数据结构来优化。</p><p><strong>那么什么时候会使用红黑树呢？</strong></p><p>在链表长度达到 8 并且 HashMap 存储的数据量大于 64 时，会将链表转化为红黑树。</p><p><strong>为什么不一开始就直接用红黑树呢？</strong></p><p>红黑树是二叉平衡树的一种，在插入和删除数据时红黑树需要通过旋转来保持“平衡”，这一过程是要付出代价的。而且红黑树节点的大小为链表节点的 2 倍，在节点太少时红黑树查找性能优势并不明显。</p><h3 id="为什么不适用其他数据结构？"><a href="#为什么不适用其他数据结构？" class="headerlink" title="为什么不适用其他数据结构？"></a>为什么不适用其他数据结构？</h3><p>如上所述，引入红黑树的目的是为了优化查询效率，但是能够优化查询效率的数据结构又不止红黑树一种，为什么不适用其他的数据结构呢？</p><p>例如二叉树、平衡二叉树、B树、B+树这些数据结构查询效率也很高，为什么不适用他们呢？</p><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>二叉树存在数据倾斜问题，极端情况下会退化成链表（只有左节点或只有右节点），不够稳定。</p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡二叉树和红黑树查询时间复杂度都是O（log n)。但是平衡二叉树有更加严格的”平衡“标准，在插入或者删除数据时，平衡二叉树需要更多的旋转才能达到平衡。</p><h4 id="B树、B-树"><a href="#B树、B-树" class="headerlink" title="B树、B+树"></a>B树、B+树</h4><p>B树和B+树的节点都能存储多个数据，在数据量不是很多的情况下，数据会”挤在“一个节点里面。这个时候遍历效率就退化成了链表。</p>]]></content>
    
    
    <summary type="html">众所周知，JDK1.8 及之后版本 HashMap 使用数组+链表+红黑树的数据结构，那么为什么引入了红黑树呢？为什么使用红黑树而不是其他的数据结构呢？</summary>
    
    
    
    <category term="Java" scheme="https://tang7o.cn/categories/Java/"/>
    
    
    <category term="Java" scheme="https://tang7o.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 一条 SQL 语句的执行过程</title>
    <link href="https://tang7o.cn/2021/11/23/MySQL-ZXGC/"/>
    <id>https://tang7o.cn/2021/11/23/MySQL-ZXGC/</id>
    <published>2021-11-23T02:37:56.000Z</published>
    <updated>2022-04-13T13:31:48.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL-驱动"><a href="#MySQL-驱动" class="headerlink" title="MySQL 驱动"></a>MySQL 驱动</h2><p>我们的系统在和 MySQL 数据库进行通信的时候，总不可能是平白无故的就能接受和发送请求，就算是你没有做什么操作，那总该是有其他的“人”帮我们做了一些事情，基本上使用过 MySQL 数据库的程序员多多少少都会知道 MySQL 驱动这个概念的。就是这个 MySQL 驱动在底层帮助我们做了对数据库的连接，只有建立连接了，才能有后面的交互。看下图表示：</p><p><img src="1.png" class="lazyload" data-srcset="1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>这样的话，在系统和 MySQL 进行交互之前，MySQL 驱动会帮我们建立好连接，然后我们只需要发送 SQL 语句就可以执行 CRUD 了。一次 SQL 请求就会建立一个连接，多个请求就会建立多个连接，那么问题来了，我们系统肯定不是一个人在使用的，换句话说肯定是存在多个请求同时去争抢连接的情况。我们的 web 系统一般都是部署在 tomcat 容器中的，而 tomcat 是可以并发处理多个请求的，这就会导致多个请求会去建立多个连接，然后使用完再都去关闭，这样会有什么问题呢？如下图：</p><p><img src="2.png" class="lazyload" data-srcset="2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>java 系统在通过 MySQL 驱动和 MySQL 数据库连接的时候是基于 TCP/IP 协议的，所以如果每个请求都是新建连接和销毁连接，那这样势必会造成不必要的浪费和性能的下降，也就是说上面的多线程请求的时候频繁的创建和销毁连接显然是不合理的。必然会大大的降低我们系统的性能，但是如果给你提供一些固定的用来连接的线程，这样是不是就不需要反复的创建和销毁连接了呢？相信懂行的朋友会会心一笑，没错，就是数据库连接池。</p><p><strong>数据库连接池</strong>：维护一定的连接数，方便系统获取连接，使用就去池子中获取，用完放回去就可以了，我们不需要关心连接的创建和销毁，也不需要关心线程池是怎么去维护这些连接的。</p><p><img src="3.png" class="lazyload" data-srcset="3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>常见的数据库连接池有 Druid、C3P0、DBCP，连接池实现原理在这里就不深入讨论了，采用连接池大大节省了不断创建与销毁线程的开销，这就是有名的「池化」思想，不管是线程池还是 HTTP 连接池，都能看到它的身影。</p><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p>到这里，我们已经知道的是我们的系统在访问 MySQL 数据库的时候，建立的连接并不是每次请求都会创建的，而是从数据库连接池中去获取，这样就解决了因为反复的创建和销毁连接带来的性能损耗问题了。不过这里有个小问题，业务系统是并发的，而 MySQL 接受请求的线程呢，只有一个？</p><p>其实 MySQL 的架构体系中也已经提供了这样的一个池子，也是数据库连接池。双方都是通过数据库连接池来管理各个连接的，这样一方面是线程之前不需要争抢连接，更重要的是不需要反复的创建和销毁连接。</p><p><img src="4.png" class="lazyload" data-srcset="4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>至此系统和 MySQL 数据库之间的连接问题已经说说明清楚了。那么 MySQL 数据库中这些连接是怎么来处理的，又是谁来处理的呢？</p><h2 id="网络连接必须由线程来处理"><a href="#网络连接必须由线程来处理" class="headerlink" title="网络连接必须由线程来处理"></a>网络连接必须由线程来处理</h2><p>对计算机基础稍微有一点了解的同学都是知道的，网络中的连接都是由线程来处理的，所谓网络连接说白了就是一次请求，每次请求都有相应的线程去处理。也就是说对于 SQL 语句的请求在 MySQL 中是由一个个线程去处理的。</p><p><img src="5.png" class="lazyload" data-srcset="5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>那这些线程会怎么去处理这些请求？会做哪些事情？</p><h2 id="SQL-接口"><a href="#SQL-接口" class="headerlink" title="SQL 接口"></a>SQL 接口</h2><p>MySQL 中处理请求的线程在获取到请求以后获取 SQL 语句去交给 SQL 接口处理。</p><h2 id="查询解析器"><a href="#查询解析器" class="headerlink" title="查询解析器"></a>查询解析器</h2><p>假设现在有这样一个 SQL。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT stuName,age,sex FROM students WHERE id=1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是这个 SQL 是写给我们人看的，机器哪会知道你在说什么？这个时候解析器就上场了。他会将 SQL 接口传递过来的 SQL 语句进行解析，翻译成 MySQL 自己能认识的语言，至于怎么解析的就不需要再深究了，无非是自己的一套规则。</p><p><img src="6.png" class="lazyload" data-srcset="6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>现在 SQL 已经被解析成 MySQL 认识的样子了，那下一步不就是执行了吗？理论上来说是这样的，但是 MySQL 的强大远不止如此，它还会帮我们选择最优的查询路径。</p><p>什么叫最优的查询路径？就是 MySQL 会按照自己认为的效率最高的方式去执行查询。</p><p>具体是怎么做到的呢？这就要说到 MySQL 的查询优化器了。</p><h2 id="MySQL-查询优化器"><a href="#MySQL-查询优化器" class="headerlink" title="MySQL 查询优化器"></a>MySQL 查询优化器</h2><p>查询优化器内部具体怎么实现的我们并不关心，我们需要知道的是 MySQL 会帮我们去使用它自己认为最好的方式去优化这条 SQL 语句，并且生成一条条的执行计划，比如你创建了多个索引，MySQL 会依据成本最小原则来选择使用响应的索引，这里的成本主要包括两个方面，IO 成本和 CPU 成本。</p><p><strong>IO 成本：</strong>即从磁盘把数据加载到内存的成本，默认情况下，读取数据页的 IO 成本是 1，MySQL 是以页的形式读取数据的，即当用到某个数据时，并不会只读取这个数据，而会把这个数据相邻的数据也一起读到内存中，这就是有名的程序局部性原理，所以 MySQL 每次会读取一整页，一页的成本是 1。所以 IO 的成本主要和页的大小有关。</p><p><strong>CPU 成本：</strong>将数据读入内存后，还需要杰测数据是否满足条件和排序等 CPU 操作的成本，显然它和行数有关，默认情况下，检测记录的成本为 0.2.</p><p>MySQL 优化器会计算「IO 成本 + CPU 成本」最小的那个索引来执行。</p><p><img src="7.png" class="lazyload" data-srcset="7.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>优化器执行选出最优索引等步骤后，会调用存储引擎接口，开始去执行被 MySQL 解析过和优化过的 SQL 语句。</p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>查询优化器会调用存储引擎的接口，去执行 SQL，也就是说真正执行 SQL 的动作是在存储引擎中完成的。数据是被存放放在内存或者是磁盘中的（存储引擎是一个非常重要的组件，后面会详细介绍）</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>执行器是一个非常重要的组件，因为前面那些组件的操作最终必须通过执行器去调用存储引擎的接口才能被执行。执行器最终根据一系列的执行计划去调用存储引擎的接口去完成 SQL 的执行。</p><p><img src="8.png" class="lazyload" data-srcset="8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><h2 id="初识存储引擎"><a href="#初识存储引擎" class="headerlink" title="初识存储引擎"></a>初识存储引擎</h2><p>我们以一个更新的 SQL 语句来说明，SQL 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE students SET stuName = &#x27;张三&#x27; WHERE id = 1</span><br></pre></td></tr></table></figure><p>当我们系统发出这样的语句去交给 MySQL 的时候，MySQL 会按照我们上面介绍的一系列的流程最终通过执行器调用存储引擎去执行，流程图就是上面那个。在执行这个 SQL 的时候 SQL 语句对应的数据要么在内存中，要么是在磁盘中，如果在磁盘中操作，那这样的随机 IO 读写的速度肯定是让人无法接受的，所以每次在执行 SQL 的时候，都会将数据加载到内存中，这块内存就是 InnoDB 中一个非常重要的组件：<strong>缓冲池 Buffer Pool</strong>。</p><h2 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h2><p>Buffer Poll（缓冲池）是 InnoDB 存储引擎中非常重要的内存结构，顾名思义，缓冲池其实就是类似 Redis 一样的作用，因为我们都知道 MySQL 的数据最终是存储在磁盘中的，如果没有这个 Buffer Poll 那么我们每次的数据库请求都会在磁盘中查找，这样必然会存才 IO 操作，这肯定是无法接受的。但是如果有了 Buffer Poll 就是我们在第一次查询的时候会将查询的结果存到 Buffer Poll 中，这样后面再有请求的时候就会先从缓冲池中查询，如果没有再去磁盘中查找，然后放到 Buffer Poll 中，如下图：</p><p><img src="9.png" class="lazyload" data-srcset="9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>按照上面的图，这条 SQL 语句的执行步骤大概是这样的：</p><ul><li>InnoDB 存储引擎会在缓冲池中查找 <code>id = 1</code> 的这条数据是否存在。</li><li>发现不存在，那么就会去磁盘中加载，并将其放在缓冲池中。</li><li>该条记录会被加上一个独占锁（总部能你在修改的时候别人也在该吧）</li></ul><h2 id="undo-日志文件：记录数据被修改前的样子"><a href="#undo-日志文件：记录数据被修改前的样子" class="headerlink" title="undo 日志文件：记录数据被修改前的样子"></a>undo 日志文件：记录数据被修改前的样子</h2><p>undo 顾名思义，就是没有做，没有发生的意思。undo log 就是没有发生事情（原本事情是什么样子）的一些日志。</p><p>我们刚刚已经说了，在准备更新一条语句的时候，该条语句已经被加载到 Buffer Pool 中来，实际上这里还有这样的操作，就是在将该条语句加载到 Buffer Poll 中的时候同时会往 undo 日志文件中插入一条日志，也就是将 <code>id = 1</code> 这条记录原来的值记录下来。</p><p><strong>这样做的目的是什么？</strong></p><p>InnoDB 存储引擎最大的特点就是支持事务，如果本次更新失败，也就是事务失败，那么该事务中的所有操作都必须回滚到执行前的样子，也就是说当事务失败的时候，也不会对原始数据有影响，如下图：</p><p><img src="10.png" class="lazyload" data-srcset="10.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>到这一步，我们执行的 SQL 语句已经被加载到 Buffer Pool 中了，然后开始更新这条语句，更新的操作实际是在 Buffer Pool 中执行的。那么问题来了，按照我们平时开发的一套理论缓冲池中的数据和数据库中的数据不一致的时候，我们就认为缓存中的数据是脏数据，那么此时 Buffer Pool 中的数据岂不是成了脏数据？没错，目前这条数据就是脏数据，Buffer Pool 中的记录是张三，数据库中的记录是李四，这种情况 MySQL 是怎么处理的呢？</p><h2 id="redo-日志文件：记录数据被修改后的样子"><a href="#redo-日志文件：记录数据被修改后的样子" class="headerlink" title="redo 日志文件：记录数据被修改后的样子"></a>redo 日志文件：记录数据被修改后的样子</h2><p>除了从磁盘中加载文件和将操作前的记录保存到 undo 日志中，其他的操作是在内存中完成的，内存中数据的特点就是：断电丢失。如果此时 MySQL 所在的服务器宕机了，那么 Buffer Pool 中的数据会全部丢失的。这个时候 redo 日志文件就需要出来大显神通了。</p><p><strong>画外音：redo 日志文件是 InnoDB 特有的，它是存储引擎级别的，不是 MySQL 级别的。</strong></p><p>redo 记录的数据修改之后的样子，不管事务是否提交都会记录下来，例如，此时要做的是<code>update students set stuName=&#39;小强&#39; where id=1;</code>那么这条操作就会被记录到 redo log buffer 中，啥？怎么又出来一个 redo log buffer，很简单，MySQL 为了提高效率，所以将这些操作都先放在内存中去完成，然后会在某个会时机将其持久化到磁盘中。</p><p><img src="11.png" class="lazyload" data-srcset="11.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>截至目前，我们应该熟悉了 MySQL 的执行器调用存储引擎是怎么将一条 SQL 加载到缓冲池和记录哪些日志的，流程如下：</p><ul><li>准备更新一条 SQL 语句</li><li>MySQL（InnoDB）会先去缓冲池（Buffer Pool）中去查找这条数据，没找到就会去磁盘中查找，如果查找到就会将这条数据加载到缓冲池（Buffer Pool）中。</li><li>在加载到 Buffer Poll 中的同时，会将这条数据的原始记录保存到 undo 日志文件中。</li><li>InnoDB 会在 Buffer Pool 中执行更新操作。</li><li>更新后的数据会记录在 redo log buffer 中。</li></ul><p>上面说的步骤都是在正常情况下的操作，但是程序的设计和优化并不仅是为了这些正常情况去做的，也是为了<strong>那些临界区和极端情况下出现的问题</strong>去优化设计的。</p><p>这个时候如果服务器宕机了，那么缓存中的数据还是丢失了。真烦，竟然数据总是丢失，那能不能不要放在内存中，直接保存到磁盘呢？很显然不行，因为在上面也已经介绍了，在内存中操作目的是为了提高效率。</p><p>此时，如果 MySQL 真的宕机了，那么没有关系的，因为 MySQL 会认为本次事务是失败的，所以数据依旧是更新前的样子，并不会有任何的影响。</p><p>好了，语句也更新好了那么需要将更新的值提交啊，也就是需要提交本次的事务了，因为只要事务成功提交了，才会将最后的变更保存到数据库，在提交事务前仍然会具有相关的其他操作。</p><p>将 redo log buffer 中的数据持久化到磁盘中，就是将 redo log buffer 中的数据写到 redo log 磁盘文件中，一般情况下，redo log buffer 数据写入磁盘的策略是立即刷入磁盘（具体策略情况在下面小总结处会详细介绍）</p><p><img src="12.png" class="lazyload" data-srcset="12.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>如果 redo log buffer 刷入磁盘后，数据库服务器宕机了，那么我们更新的数据怎么办？此时数据是在内存中，数据岂不是丢失了？不，这次数据就不会丢失了，因为 redo log buffer 中的数据已经被写入磁盘了，已经持久化了，就是数据库宕机了，在下次重启的时候 MySQL 也会将 redo 日志文件内容恢复到 Buffer pool 中（这边我理解的是和 Redis 的持久化机制是差不多的，在 Redis 启动的时候会检查 rdb 或者 aof 或者两者都检查，根据持久化的文件来将数据恢复到内存中）</p><p>到处为止，<strong>从执行器开始调用存储引擎接口做了哪些事情呢？</strong></p><ul><li>准备一条 SQL 语句。</li><li>MySQL（InnoDB）会先去缓冲池（Buffer Pool）中去查找这条数据，没找到就会去磁盘中查找，如果查找到就会将这条数据加载到缓冲池（Buffer Pool）中。</li><li>在加载到 Buffer Poll 中的同时，会将这条数据的原始记录保存到 undo 日志文件中。</li><li>InnoDB 会在 Buffer Pool 中执行更新操作。</li><li>更新后的数据会记录在 redo log buffer 中。</li><li>MySQL 提交事务的时候，会将 redo log buffer 中的数据写入到 redo 日志文件中，刷磁盘可以通过 <code>innodb_flush_log_at_trx_commit</code> 参数来设置。<ul><li>值为 0 表示不刷入磁盘</li><li>值为 1 表示立即刷入磁盘</li><li>值为 2 表示先刷到 os cache</li></ul></li><li>MySQL 重启时会将 redo 日志恢复到缓冲池中。</li></ul><p>截至到目前位置，MySQL 的执行器调用存储引擎的接口去执行「执行计划」提供的 SQL 的时候 InnoDB 做了哪些事情也就差基本差不多了，但是这还没完。下面还需要介绍下 MySQL 级别的日志 bin log。</p><h2 id="bin-log-日志文件：记录整个操作过程"><a href="#bin-log-日志文件：记录整个操作过程" class="headerlink" title="bin log 日志文件：记录整个操作过程"></a>bin log 日志文件：记录整个操作过程</h2><p>上面介绍到的 redo log 是 InnoDB 存储引擎特有的日志文件，而 bin log 是属于 MySQL 级别的日志。redo log 记录的东西是偏向于物理性质的，如：“对上面数据，做了什么修改”。bin log 是偏向于逻辑性质的，类似于：“对 students 表中 id 为 1 的记录做了更新操作”两者的主要特点总结如下。</p><div class="table-container"><table><thead><tr><th>性质</th><th>redo log</th><th>bin log</th></tr></thead><tbody><tr><td>文件大小</td><td>大小固定（配置中也可以设置，一般默认的就足够了）</td><td>可以通过配置参数 <code>max_bin log_size</code> 修改每个 bin log 的大小（但是一般不建议修改）。</td></tr><tr><td>实现方式</td><td>InnoDB 引擎实现的（也就是说是 InnoDB  存储引擎独有的）</td><td>MySQL 层实现的，所有引擎都可以使用。</td></tr><tr><td>记录方式</td><td>循环写的方式记录，当写到结尾时，会回到开头循环写日志。</td><td>追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上。</td></tr><tr><td>使用场景</td><td>适用于崩溃恢复（crash-safe）（这一点其实非常类似 Redis 的持久化特征）</td><td>适用于主从复制和数据恢复。</td></tr></tbody></table></div><p><strong>bin log 文件是如何刷入磁盘的？</strong></p><p>bin log 的刷盘是有相关的策略的，策略可以通过 <code>sync_bin log</code> 来修改，默认为 0，表示先写入 os cache，也就是在提交事务的时候，数据不会直接刷到磁盘中，这样如果宕机 bin log 数据仍然会丢失。所以建议将 <code>sync_bin log</code> 设置为 1 表示直接将数据写入到磁盘文件中。</p><p>刷入 bin log 有以下几种模式：</p><ul><li><strong>STATMENT</strong></li></ul><p>基于 SQL 语句的复制（statement-based replication, SBR)，每一条会修改数据的 SQL 语句会记录到 bin log 中。</p><p>【优点】：不需要记录每一行的变化，减少了 bin log 的日志量，节约了 IO，从而提高了性能。</p><p>【缺点】：在某些情况下会导致主从数据不一致，比如执行 <code>sysdat()</code>、<code>sleep()</code> 等。</p><ul><li><strong>ROW</strong></li></ul><p>基于行的复制（row-based replication, RBR），不记录每条SQL语句的上下文信息，仅需记录哪条数据被修改了。</p><p>【优点】：不会出现某些特定情况下的存储过程、或 function、或 trigger 的调用和触发无法被正确复制的问题。</p><p>【缺点】：会产生大量的日志，尤其是 <code>alter table</code> 的时候会让日志暴涨。</p><ul><li><strong>MIXED</strong></li></ul><p>基于 STATMENT 和 ROW 两种模式的混合复制（mixed-based replication, MBR），一般的复制使用 STATEMENT 模式保存 bin log，对于 STATEMENT 模式无法复制的操作使用 ROW 模式保存 bin log。</p><p>那既然 bin log 也是日志文件，那它是在什么时候记录数据呢？</p><p>其实 MySQL 在提交事务的时候，不仅仅会将 redo log buffer 中的数据写入 redo log 文件中，同时也会将本次修改的数据记录到 bin log 文件中，同时会将本次修改的 bin log 文件名和修改的内容在 bin log 中的位置记录到 redo log 中，最好还会在 redo log 写入 commit 标记，这样就表示本次事务被成功的提交了。</p><p><img src="13.png" class="lazyload" data-srcset="13.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>如果在数据被写入到 bin log 文件的时候，数据库宕机了，数据还会丢失吗？</p><p>首先可以确定的是，只要 redo log 最后没有 commit 标记，说明本次事务一定是失败的。但是数据是没有丢失的，因为已经记录到 redo log 的磁盘文件中了。在 MySQL 重启的时候，就会将 redo log 的数据恢复（加载）到 Buffer pool 中。</p><p>好了，到目前为止，一个更新操作我们基本介绍的差不多了，但是你有没有感觉少了哪些事情还没有做？是不是你也发现这个时候被更新的记录仅仅是在内存中执行的，哪怕是宕机又恢复了也仅仅是将更新后的记录加载到 Buffer Pool 中，这个时候 MySQL 数据库中的这条记录依旧是旧值，也就是说内存中的数据在我们看来依旧是脏数据，那这个时候怎么办呢？</p><p>其实 MySQL 会有一个后台线程，它会在某个时机将我们 Buffer Pool 中的脏数据刷到 MySQL 数据库中，这样就将内存和数据库中的数据保持统一了。</p><p><img src="14.png" class="lazyload" data-srcset="14.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><h2 id="本文总结"><a href="#本文总结" class="headerlink" title="本文总结"></a>本文总结</h2><p>到此，关于 Buffer Pool、redo log buffer 和 undo log、redo log、bin log 概念以及关系就基本差不多了。</p><p>我们再回顾下</p><ul><li>Buffer Pool 是 MySQL 的一个非常重要的组件，因为针对数据库的增删改操作都是在 Buffer Pool 中完成的</li><li>undo log 记录的是数据操作前的样子</li><li>redo log 记录的是数据被操作后的样子（redo log 是 InnoDB 存储引擎特有）</li><li>bin log 记录的是整个操作记录（这个对于主从复制具有非常重要的意义）</li></ul><p>从准备更新一条数据到事务的提交的流程描述</p><ul><li>首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中</li><li>在数据被缓存到缓存池的同时，会写入 undo log 日志文件</li><li>更新的动作是在 Buffer Pool 中完成的，同时会将更新后的数据添加到 redo log buffer 中。</li><li>完成以后就可以提交事务，在提交的同时会做以下三件事<ul><li>将 redo log buffer 中的数据刷入到 redo log 文件中。</li><li>将本次操作记录写入到 bin log 文件中。</li><li>将 bin log 文件名字和更新内容在 bin log 中的位置记录到 redo log 中，同时在 redo log 最后添加 commit 标记。</li></ul></li></ul><p>至此表示整个更新事务已经完成。</p><h2 id="文章来源"><a href="#文章来源" class="headerlink" title="文章来源"></a>文章来源</h2><ul><li>作者：码海</li><li>原文链接：<a href="https://blog.csdn.net/weixin_41385912/article/details/112975752">传送门</a></li></ul>]]></content>
    
    
    <summary type="html">天天和数据库打交道，一天能写上几十条 SQL 语句，但你知道我们的系统是如何和数据库交互的吗？MySQL 如何帮我们存储数据、又是如何帮我们管理事务？是不是感觉真的除了写几个「select * from dual」外基本脑子一片空白？这篇文章就将带你走进 MySQL 的世界，让你彻底了解系统到底是如何和 MySQL 交互的，MySQL 在接受到我们发送的 SQL 语句时又分别做了哪些事情。</summary>
    
    
    
    <category term="MySQL" scheme="https://tang7o.cn/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://tang7o.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 性能优化</title>
    <link href="https://tang7o.cn/2021/11/19/MySQL-XNYH/"/>
    <id>https://tang7o.cn/2021/11/19/MySQL-XNYH/</id>
    <published>2021-11-19T00:17:24.000Z</published>
    <updated>2022-04-13T13:31:48.217Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用-Explain-进行分析"><a href="#使用-Explain-进行分析" class="headerlink" title="使用 Explain 进行分析"></a>使用 Explain 进行分析</h2><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p><p>比较重要的字段有:</p><ul><li>select_type : 查询类型，有简单查询、联合查询、子查询等</li><li>key : 使用的索引</li><li>rows : 扫描的行数</li></ul><h2 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h2><h3 id="1-减少请求的数据量"><a href="#1-减少请求的数据量" class="headerlink" title="1. 减少请求的数据量"></a>1. 减少请求的数据量</h3><ul><li>只返回必要的列: 最好不要使用 SELECT * 语句。</li><li>只返回必要的行: 使用 LIMIT 语句来限制返回的数据。</li><li>缓存重复查询的数据: 使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li></ul><h3 id="2-减少服务器端扫描的行数"><a href="#2-减少服务器端扫描的行数" class="headerlink" title="2. 减少服务器端扫描的行数"></a>2. 减少服务器端扫描的行数</h3><p>最有效的方式是使用索引来覆盖查询。</p><h2 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h2><h3 id="1-切分大查询"><a href="#1-切分大查询" class="headerlink" title="1. 切分大查询"></a>1. 切分大查询</h3><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p><h3 id="2-分解大连接查询"><a href="#2-分解大连接查询" class="headerlink" title="2. 分解大连接查询"></a>2. 分解大连接查询</h3><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，这样做的好处有:</p><ul><li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li><li>减少锁竞争；</li><li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li><li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用-Explain-进行分析&quot;&gt;&lt;a href=&quot;#使用-Explain-进行分析&quot; class=&quot;headerlink&quot; title=&quot;使用 Explain 进行分析&quot;&gt;&lt;/a&gt;使用 Explain 进行分析&lt;/h2&gt;&lt;p&gt;Explain 用来分析 SELEC</summary>
      
    
    
    
    <category term="MySQL" scheme="https://tang7o.cn/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://tang7o.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 引擎</title>
    <link href="https://tang7o.cn/2021/11/16/MySQL-YQ/"/>
    <id>https://tang7o.cn/2021/11/16/MySQL-YQ/</id>
    <published>2021-11-16T12:46:12.000Z</published>
    <updated>2022-04-13T13:31:48.231Z</updated>
    
    <content type="html"><![CDATA[<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>是 MySQL 默认的事务型存储引擎，<strong>只有在需要它不支持的特性时，才考虑使用其它存储引擎</strong>。</p><p>实现了四个标准的隔离级别，默认级别为可重复读。在可重复读的级别下，通过多版本并发控制（MVCC）+间隙锁（Next-Key Locking）防止幻读。</p><p>基于聚簇索引（主索引）建立，在主索引中保存数据。与其他存储引擎有很大的区别，聚簇索引对主键查询有很高的性能，不过它的二级索引（非主键索引）必须包含主键列。所以如果主键列很大的话，索引会很大。</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>在5.1之前，MyISAM 是默认的引擎，MyISAM 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p><p>提供了大量的特性，包括压缩表、空间数据索引等。</p><p>但是 MyISAM 不支持事务和行级锁，而且在崩溃后无法安全恢复。即使后续版本中 MyISAM 支持了事务，但是很多人的概念中依然是不支持事务的引擎。</p><p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><h4 id="事务和外键"><a href="#事务和外键" class="headerlink" title="事务和外键"></a>事务和外键</h4><p>InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</p><p>InnoDB 支持外键。</p><h4 id="锁和并发"><a href="#锁和并发" class="headerlink" title="锁和并发"></a>锁和并发</h4><p>MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</p><p>MyISAM 读写互相阻塞：不仅会在写入的时候阻塞读取，MyISAM 还会在读取的时候阻塞写入，但读本身并不会阻塞另外的读。</p><p>InnoDB 读写阻塞与事务隔离级别相关。</p><h4 id="索引和存储"><a href="#索引和存储" class="headerlink" title="索引和存储"></a>索引和存储</h4><p>MyISAM 和 InnoDB 的索引都采用了 B+ 树的结构。</p><p>MyISAM 的索引和数据是分开的，是<strong>非聚簇索引。</strong>叶子节点存放索引键和数据记录的地址，如下图所示：</p><p><img src="1.png" class="lazyload" data-srcset="1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>MyISAM 引擎将数据存储成三个文件，以表名命名，扩展名指出文件类型。</p><ul><li>.frm 文件存储表定义。</li><li>.MYD 文件存储数据。</li><li>.MYI 文件存储索引。</li></ul><p>而 InnoDB 引擎的数据存储在聚簇索引（主键建立的索引）的叶子节点中，如下图所示：</p><p><img src="2.png" class="lazyload" data-srcset="2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>InnoDB 的非聚簇索引的叶子节点存储了该条记录的主键。如下图所示：</p><p><img src="3.png" class="lazyload" data-srcset="3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>因此使用非聚簇索引查询数据时，还需要利用聚簇索引再查询一遍（回表查询）。但是有一种情况例外：你要查询的信息包含在索引内（覆盖索引）。</p><p><strong>注意：MyISAM 表是保存成文件的形式，在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦</strong>。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>MyISAM 引擎保存了表中数据的行数，查询时可以直接读取。InnoDB 引擎需要扫描一遍表来计算行数。<strong>但是如果查询语句中包含了 <code>where</code> 条件时，两种引擎的操作是一样的。</strong></li><li><code>DELETE FROM table</code> 时，InnoDB 不会重新建立表，而是一行一行的删除。</li><li>如果执行大量的 <code>SELECT</code>，MyISAM 是更好的选择，如果你的数据执行大量的 <code>INSERT</code> 或 <code>UPDATE</code>，出于性能方面的考虑，应该使用 <code>InnoDB</code> 表。</li></ul>]]></content>
    
    
    <summary type="html">MyISAM 引擎和 InnoDB 引擎分别为 MySQL 5.1 前后的默认引擎，它们之间有什么区别？</summary>
    
    
    
    <category term="MySQL" scheme="https://tang7o.cn/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://tang7o.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务ACID实现原理</title>
    <link href="https://tang7o.cn/2021/11/13/MySQL-ACID/"/>
    <id>https://tang7o.cn/2021/11/13/MySQL-ACID/</id>
    <published>2021-11-13T11:40:15.000Z</published>
    <updated>2022-04-13T13:31:48.190Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>实现原理：利用 undo log。</p><p>undo log 名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的 sql 语句，他需要记录你要回滚的相应日志信息：</p><ul><li>当你 delete 一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert 这条旧数据</li><li>当你 update 一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行 update 操作</li><li>当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行 delete 操作</li></ul><p>undo log 记录了这些回滚需要的信息，当事务执行失败或调用了 rollback ，导致事务需要回滚，便可以利用 undo log 中的信息将数据回滚到修改之前的样子。</p><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>实现原理：利用 redo log。</p><p>MySQL 先把磁盘上的数据加载到内存，在内存中进行修改，再刷回磁盘。如果此时突然宕机，内存中的数据将会丢失。</p><p>如何解决这个问题？</p><p>事务提交前直接把数据写入磁盘？这样做存在以下的问题：</p><ul><li>只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面 16kb 大小，你只改其中一点点东西，就要将 16kb 的内容刷入磁盘，听着也不合理。</li><li>毕竟一个事务里的 SQL 可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机 IO。显然操作随机 IO，速度会比较慢。</li></ul><p>于是，采用 redo log 解决上面的问题。当修改数据时，不仅在内存中修改，还会在 redo log 中记录这次操作。当事务提交的时候，会将 redo log 日志进行刷盘（redo log 一部分在内存中，一部分在磁盘上）。当数据库宕机重启的时候，会将 redo log 的内容恢复到数据库中，再根据 undo log 和 bin log 来决定回滚还是提交数据。</p><p><strong>采用 redo log 的好处（相对直接将数据写入磁盘）：</strong></p><ul><li>redo log 体积小，只记录了哪一页修改了什么，刷盘快。</li><li>redo log 是一直往末尾追加，属于顺序 IO。效率更高。</li></ul><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>实现原理：锁 + MVCC。</p><p>锁很简单，就是事务在修改数据的时候需要获取锁、上锁之类的操作。</p><p>MVCC：多版本并发控制（Multi Version Concurrency Control），一个行记录数据有多个版本对快照数据，这些快照数据在 undo log 中。</p><p>如果一个事务读取的行正在做 DELELE 或者 UPDATE 操作，读取操作不会等行上的锁释放，而是读取该行的快照版本。</p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C（一致性）是目的，A（原子性）、I（隔离性）、D（持久性）是手段，是为了保证一致性，数据库提供的手段。数据库必须要实现AID三大特性，才有可能实现一致性。</p><p>数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等。</p><p>应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致。</p>]]></content>
    
    
    <summary type="html">简单的记录了MySQL事务ACID的实现原理。</summary>
    
    
    
    <category term="MySQL" scheme="https://tang7o.cn/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://tang7o.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis事务</title>
    <link href="https://tang7o.cn/2021/11/11/Redis%E4%BA%8B%E5%8A%A1/"/>
    <id>https://tang7o.cn/2021/11/11/Redis%E4%BA%8B%E5%8A%A1/</id>
    <published>2021-11-11T13:32:15.000Z</published>
    <updated>2022-04-13T13:31:48.282Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 通过 MULTI、EXEC、WATCH 等命令来实现事务功能。事务提供一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制。</p><p>以下是一个事务的执行过程，该事务首先以一个 MULTI 命令为开始，接着将多个命令放入事务中，最后由 EXEC 命令将这个事务提交给服务器执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET &quot;name&quot; &quot;Practical Common Lisp&quot;</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; GET &quot;name&quot;</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; SET &quot;author&quot; &quot;Peter Seibel&quot;</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; GET &quot;author&quot;</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) &quot;Practical Common Lisp&quot;</span><br><span class="line">3) OK</span><br><span class="line">4) &quot;Peter Seibel&quot;</span><br></pre></td></tr></table></figure><h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><p>一个事务从开始到结束通常会经历以下三个阶段：</p><ol><li>事务开始。</li><li>命令入队。</li><li>事务执行。</li></ol><h3 id="事务开始"><a href="#事务开始" class="headerlink" title="事务开始"></a>事务开始</h3><p>MULTI 命令的执行标志着事务的开始：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>MULTI 命令可以将执行该命令的客户端从非事务状态切换到事务状态，这一切换是通过在客户端状态的 flags 属性中打开 REDIS_MULTI 标识来完成的，具体实现可以用以下伪代码来表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">MULTI</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">#打开事务标识识</span></span><br><span class="line"><span class="function">client.flags |=</span> REDIS_MULTI</span><br><span class="line">#返回OK回复</span><br><span class="line"><span class="built_in">replyOK</span>()</span><br></pre></td></tr></table></figure><h3 id="命令入队"><a href="#命令入队" class="headerlink" title="命令入队"></a>命令入队</h3><p>当一个客户端还处于非事务状态时，这个客户端发送的命令会立即被服务器执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET &quot;name&quot; &quot;Practical Common Lisp&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET &quot;name&quot;</span><br><span class="line">&quot;Practical Common Lisp&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; SET &quot;author&quot; &quot;Peter Seibel&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET &quot;author&quot;</span><br><span class="line">&quot;Peter Seibel&quot;</span><br></pre></td></tr></table></figure><p>与此不同的是，当一个客户端切换到事务状态之后，服务器会根据这个客户端发来的不同命令执行不同的操作：</p><ul><li>如果命令为 EXEC、DISCARD、WATCH、MULTI四 个命令中的其中一个，那么服务器会立即执行这个命令。</li><li>其他的命令不会立即执行，而是将这个命令放入一个事务队列里面，然后向客户端返回 QUEUED 回复。</li></ul><p><img src="1.png" class="lazyload" data-srcset="1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><h3 id="事务队列"><a href="#事务队列" class="headerlink" title="事务队列"></a>事务队列</h3><p>每个 Redis 客户端都有自己的事务状态，这个事务状态保存在客户端状态的 mstate 属性中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisClient</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//事务状态</span></span><br><span class="line">    multiState mstate; <span class="comment">/* MULTI/EXEC state */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><p>事务状态包含一个事务对象，以及一个已入队命令的计数器（事务队列的长度）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">multiState</span> &#123;</span><br><span class="line">    <span class="comment">//事务队列，FIFO顺序</span></span><br><span class="line">    multiCmd *commands;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//已入队命令计数</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125; multiState;</span><br></pre></td></tr></table></figure><p>事务队列是一个 multiCmd 类型的数组，数组中每个 multiCmd 结构都保存来一个已入队的命令的相关信息，包含指向命令实现函数的指针、命令参数，以及参数的数量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">multiCmd</span> &#123;</span><br><span class="line">    <span class="comment">//参数</span></span><br><span class="line">    robj **argv;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//参数数量</span></span><br><span class="line">    <span class="type">int</span> argc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//命令指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">redisCommand</span> *cmd;</span><br><span class="line">&#125; multiCmd;</span><br></pre></td></tr></table></figure><h3 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h3><p>当一个处于事务状态的客户端向服务器发送 EXEC 命令时，这个 EXEC 命令会立即被执行。服务器会遍历客户端的事务队列，执行队列中的所有命令，最后将执行的结果全部返回给客户端。</p><p>EXEC 的实现原理可以用以下伪代码来描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def EXEC():</span><br><span class="line">    # 创建空白的回复队列</span><br><span class="line">    reply_queue = []</span><br><span class="line">    </span><br><span class="line">    # 遍历事务队列中的每个项</span><br><span class="line">    # 读取命令的参数、参数个数、以及要执行的命令</span><br><span class="line">    for argv, argc, cmd in client.mstate.commands:</span><br><span class="line">        # 执行命令，并取得命令的返回值</span><br><span class="line">        reply = execute_command(cmd, argv, argc)</span><br><span class="line">        # 将返回值加到回复队列末尾</span><br><span class="line">        reply_queue.append(reply)</span><br><span class="line">        </span><br><span class="line">    # REDIS_MULTI 标识，让客户端回到非事务状态</span><br><span class="line">    client.flags &amp; = ~REDIS_MULTI</span><br><span class="line">    </span><br><span class="line">    # 清空客户端的事务状态，包括：</span><br><span class="line">    # 1）清零入队命令计数器</span><br><span class="line">    # 2）释放事务队列</span><br><span class="line">    client.mstate.count = 0</span><br><span class="line">    release_transaction_queue(client.mstate.commands)</span><br><span class="line">    </span><br><span class="line">    # 将事务的执行结果返回给客户端</span><br><span class="line">    send_reply_to_client(client, reply_queue)</span><br></pre></td></tr></table></figure><h2 id="WATCH-命令的实现"><a href="#WATCH-命令的实现" class="headerlink" title="WATCH 命令的实现"></a>WATCH 命令的实现</h2><p>WATCH 命令是一个乐观锁，它可以在 EXEC 命令执行前，监视任意数量的键，并在 EXEC 命令执行时，检查被监视的键是否至少有一个被修改过，如果是，服务器拒绝执行事务，并向客户端返回代表事务执行失败的空回复。</p><p><strong>注意：EXEC 命令开始执行后遍历事务队列执行事务，因此事务中的修改不对 WATCH 造成影响。</strong></p><h3 id="使用-WATCH-命令监视数据库键"><a href="#使用-WATCH-命令监视数据库键" class="headerlink" title="使用 WATCH 命令监视数据库键"></a>使用 WATCH 命令监视数据库键</h3><p>每个 Redis 数据库都保存着一个 watched_keys 字典，这个字典的键是某个被 WATCH 命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisDb</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//正在被WATCH命令监视的键</span></span><br><span class="line">    dict *watched_keys;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>通过 watched_keys 字典，服务器可以清楚的指导那些数据库键正在被监视，以及哪些客户端正在监视这些数据库键。</p><p>假设当前客户端为 c10086,数据库 watched_keys 字典状态为下图所示：</p><p><img src="2.png" class="lazyload" data-srcset="2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>当 c10086 执行以下命令后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; WATCH &quot;name&quot; &quot;age&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>数据库 watched_keys 字典状态变为下图所示：</p><p><img src="3.png" class="lazyload" data-srcset="3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><h3 id="监视机制的触发"><a href="#监视机制的触发" class="headerlink" title="监视机制的触发"></a>监视机制的触发</h3><p>所有对数据库进行修改的命令，在执行之前都会调用 <code>multi.c/touchWatchKey</code> 函数对 watched_keys 字典进行检查，查看是否有客户端正在监视要修改的键，如果有的话，<code>touchWatchKey</code> 函数会将监视被修改键的客户端的 <code>REDIS_DIRTY_CAS</code> 标识打开，标识该客户端的事务安全性已经被破坏。</p><p><code>touchWatchKey</code> 函数的定义可以用以下伪代码来描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def touchWatchKey(db, key):</span><br><span class="line">    # 如果键 key 存在于数据库的 watched_keys 字典中</span><br><span class="line">    # 那么说明至少有一个客户端在监视这个 key</span><br><span class="line">    if key in db.watched_keys:</span><br><span class="line">    # 遍历所有监视 key 的客户端</span><br><span class="line">        for client in db.watched_keys[key]:</span><br><span class="line">            # 打开 REDIS_DIRTY_CAS 标识</span><br><span class="line">            client.flags |= REDIS_DIRTY_CAS</span><br></pre></td></tr></table></figure><h3 id="判断事务是否安全"><a href="#判断事务是否安全" class="headerlink" title="判断事务是否安全"></a>判断事务是否安全</h3><p>当服务器接收到客户端发来的 EXEC 命令时，服务器会根据这个客户端是否打开了 <code>REDIS_DIRTY_CAS</code> 标识来决定是否执行事务：</p><p><img src="4.png" class="lazyload" data-srcset="4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><h2 id="事务的-ACID-性质"><a href="#事务的-ACID-性质" class="headerlink" title="事务的 ACID 性质"></a>事务的 ACID 性质</h2><p>在 Redis 中，事务总是具有原子性（Atomicity）、一致性（Consistency）和隔离性（Isolation），某种特定的持久化情况下具有持久性（Durability）。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>事务具有原子性是指，数据库将事务中的多个操作当作一个整体来执行，要么都执行，要么就一个也不执行。</p><p>对于 Redis 的事务功能来说，事务队列中的命令要么全部执行，要么就一个都不执行，因此，Redis 的事务是具有原子性的。</p><p>例子，成功执行的事务，事务的命令都会被执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET msg &quot;hello&quot;</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; GET msg</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) &quot;hello&quot;</span><br></pre></td></tr></table></figure><p>例子，执行失败的事务，这个事务因为命令入队出错而被服务器拒绝执行，事务的命令都不会执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis&gt; SET msg &quot;hello&quot;</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; GET</span><br><span class="line">(error) ERR wrong number of arguments for &#x27;get&#x27; command</span><br><span class="line">redis&gt; GET msg</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; EXEC</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></table></figure><p>Redis 事务和传统的关系数据库事务最大的区别在于：Redis 不支持事务回滚机制，即时事务队列中的某个命令在<strong>执行期间</strong>出现了错误，整个事务也会继续执行下去，直到事务执行完毕。</p><p>例子，即时 RPUSH 命令在<strong>执行期间</strong>出现了错误，事务的后续命令也会继续执行下去，并且之前执行的命令也不会有任何影响：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SADD fruit &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH msg &quot;good bye&quot; &quot;bye bye&quot; # 错误的对字符串键 msg 执行列表键的操作</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; SADD alphabet &quot;a&quot; &quot;b&quot; &quot;c&quot;</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC</span><br><span class="line">1) (integer) 3</span><br><span class="line">2) (error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">3) (integer) 3</span><br></pre></td></tr></table></figure><blockquote><p>Redis 的作者在事务功能的文章中解释说：不支持事务回滚是因为这种复杂的功能和 Redis 追求简单高效的设计主旨不相符，并且他认为，Redis 事务的执行时错误通常都是编译错误产生的，这种错误通常只会出现在开发环境中，而很少在实际的生产环境中出现，所以他认为没有必要为 Redis 开发事务回滚功能。</p></blockquote><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>事务具有一致性指的是，如果数据库在执行事务之前是一致的，那么在执行事务之后，无论事务是否执行成功，数据库也应该仍然是一致的。</p><p>“一致”是指数据符合数据库本身的定义和要求，没有包含非法或无效的错误数据。</p><p>Redis 通过谨慎的错误检测和简单的设计来保证事务的一致性，以下三部分分别介绍三个 Redis 事务可能出错的地方，并说明 Redis 是如何处理这些错误，从而确保事务的一致性。</p><h4 id="1-入队错误"><a href="#1-入队错误" class="headerlink" title="1.入队错误"></a>1.入队错误</h4><p>如果一个事务在入队命令的过程中，出现了命令不存在，或者命令的格式不正确等情况，那么 Redis 将拒绝执行这个事务。</p><p>例子，因为客户端尝试向事务入队一个不存在的命令 Tang7O，所以客户端提交的事务会被服务器拒绝执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET msg &quot;hello&quot;</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; YAHOOOO</span><br><span class="line">(error) ERR unknown command &#x27;Tang7O&#x27;</span><br><span class="line"></span><br><span class="line">redis&gt; GET msg</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></table></figure><p>因为服务器会拒绝执行入队错误的事务，因此 Redis 事务的一致性不会被带有入队错误的事务影响。</p><blockquote><p>Redis 2.6.5 以前的版本，即时有命令在入队过程中发生了错误，事务一样可以执行，不过被执行的命令只包括哪些正确入队的命令。</p></blockquote><h4 id="2-执行错误"><a href="#2-执行错误" class="headerlink" title="2.执行错误"></a>2.执行错误</h4><p>除了入队时可能发生错误外，事务还可能在执行过程中发生错误。</p><ul><li>执行过程中发生的错误都是一些不能在入队时被服务器发现的错误，这些错误只会在命令实际执行时被触发。</li><li>即使在事务的执行过程中发生了错误，服务器也不会中断事务的执行，它会继续执行事务中余下的其他命令，并且已经执行的命令不会被出错的命令影响。</li></ul><p>例子，用列表键的 RPUSH 命令操作字符串键。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SADD fruit &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH msg &quot;good bye&quot; &quot;bye bye&quot;</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; SADD alphabet &quot;a&quot; &quot;b&quot; &quot;c&quot;</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC</span><br><span class="line">1) (integer) 3</span><br><span class="line">2) (error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">3) (integer) 3</span><br></pre></td></tr></table></figure><p>因为在事务执行的过程中，出错的命令会被服务器识别出来，并进行响应的处理，所以不会对事务的一致性产生影响。</p><h4 id="3-服务器停机"><a href="#3-服务器停机" class="headerlink" title="3.服务器停机"></a>3.服务器停机</h4><p>如果 Redis 服务器在事务执行过程中停机，那么根据服务器所使用的持久化模式，可能有以下情况出现：</p><ul><li><p><strong>无持久化</strong>：重启之后数据库是空白的，因此数据总是一致的。</p></li><li><p><strong>RDB 持久化</strong>：事务中途停机不会导致不一致性，因为服务器可以根据现有的 RDB 文件来恢复数据，从而将数据库还原到一个一致性状态。如果找不到可供使用的 RDB 文件，那么重启之后数据库将是空白的，而空白数据库总是一致的。</p></li><li><strong>AOF 持久化</strong>：服务器可以根据现有的 AOF 文件来恢复数据，从而将数据库还原到一个一致性状态。找不到可供使用的 AOF 文件，那么重启之后数据库将是空白的，而空白数据库总是一致的。</li></ul><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>事务的隔离性是指：即时数据库有多个事务并发地执行，各个事务之间也不会互相影响，并且在并发的状态下执行的事务和串行执行事务的结果完全相同。</p><p>因为 Redis 使用单线程来执行事务，并且服务器保证，在执行事务期间不会对事务进行中断，因此，Redis 的事务总是以串行的方式进行的，并且事务也总是具有隔离性的。</p><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>事务的持久性是指：当一个事务执行完毕时，执行这个事务所获得的结果已经被保存到永久性存储介质（比如硬盘）里面，即时服务器在事务执行完毕之后停机，执行事务所得的结果也不会丢失。</p><p>因为 Redis 的事务不过是简单地用队列包裹起了一组 Redis 命令，Redis 并没有为事务提供任何额外的持久化功能，所以 Redis 事务的持久性由 Redis  所使用的持久化模式来决定：</p><ul><li><p><strong>无持久化</strong>：事务不具有持久性，一旦服务器停机，包括事务数据在内的所有数据都将丢失。</p></li><li><p><strong>RDB 持久化</strong>：服务器只在特定的保存条件被满足时才会执行 BGSAVE 命令，对数据库进行保存操作，并且异步执行的 BGSAVE 不能保证事务数据第一时间被保存到硬盘里面，因此 RDB 持久模式下的事务也不具有持久性。</p></li><li><p><strong>AOF 持久化</strong>：</p><ul><li><p>appendfsync 选项的值为 always 时，程序总会在执行命令之后调用同步（sync）函数，将命令数据真正的保存到池盘里面，这种配置下的事务是具有持久性的。</p></li><li><p>appendfsync 选项的值为 everysec 时，程序会每秒同步一次命令数据到磁盘。因此停机可能会恰好发生在等待同步的那一秒内，这可能会造成事务数据丢失，所以这种配置下事务不具有持久性。</p></li><li>appendfsync 选项的值为 no 时，程序会交由操作系统来决定何时将命令数据同步到硬盘。因此事务数据可能在等待同步的过程中丢失，所以这种模式下不具有持久性。</li></ul></li></ul><p>不论 Redis 在什么模式下运作，在一个事务的后面加上 SAVE 命令总是可以保证事务的持久性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET msg &quot;hello&quot;</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; SAVE</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br></pre></td></tr></table></figure><p>不过因为这种做法的效率太低，所以不具有实用性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis 通过 MULTI、EXEC、WATCH 等命令来实现事务功能。事务提供一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制。&lt;/p&gt;
&lt;p&gt;以下是一个事务的执行过程，该事务首先以一个 MULTI 命令为开始，接着将多个命令放入事务中，最后由 EXEC </summary>
      
    
    
    
    <category term="Redis" scheme="https://tang7o.cn/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://tang7o.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Redis 复制</title>
    <link href="https://tang7o.cn/2021/11/05/%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redis%E5%A4%8D%E5%88%B6/"/>
    <id>https://tang7o.cn/2021/11/05/%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redis%E5%A4%8D%E5%88%B6/</id>
    <published>2021-11-05T01:16:24.000Z</published>
    <updated>2022-04-13T13:31:49.009Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么主从复制使用-RDB-而不使用-AOF？"><a href="#为什么主从复制使用-RDB-而不使用-AOF？" class="headerlink" title="为什么主从复制使用 RDB 而不使用 AOF？"></a>为什么主从复制使用 RDB 而不使用 AOF？</h3><p>1、RDB 文件内容是经过压缩的二进制数据（不同数据类型数据做了针对性优化），文件很小。而 AOF 文件记录的是每一次写操作的命令，写操作越多文件会变的很大，其中还包括很多对同一个 key 的冗余操作。在主从全数据同步时，传输 RDB 文件可以尽量降低对主库机器网络宽带的消耗，从库在加载 RDB 文件时，一是文件小，读取整个文件的速度会很快，二是因为 RDB 文件存储的都是二进制数据，从库直接按照 RDB 协议解析还原数据即可，速度会非常快，而 AOF 需要依次重放每个写命令，这个过程会经历冗长的处理逻辑，恢复速度比 RDB 会慢很多，所以使用 RDB 进行主从复制。</p><p>2、假设要使用 AOF 做全量复制，意味着必须打开 AOF 功能，打开 AOF 就要选择文件刷盘的策略，选择不当会严重影响 Redis 性能，而 RDB 只有在需要定时备份和主从全量复制数据时才会触发生成一次快照。而在很多丢失数据不敏感的业务场景，其实是不需要开启 AOF 的。</p><h3 id="当主服务器不进行持久化时复制的安全性"><a href="#当主服务器不进行持久化时复制的安全性" class="headerlink" title="当主服务器不进行持久化时复制的安全性"></a>当主服务器不进行持久化时复制的安全性</h3><blockquote><p>在进行主从复制设置时，强烈建议在主服务器上开启持久化，当不能这么做时，比如考虑到延迟的问题，应该将实例配置为避免自动重启。</p></blockquote><p><strong>为什么不持久化的主服务器自动重启非常危险呢</strong>？为了更好的理解这个问题，看下面这个失败的例子，其中主服务器和从服务器中数据库都被删除了。</p><ul><li>我们设置节点 A 为主服务器，关闭持久化，节点 B 和 C 从节点 A 复制数据。</li><li>这是出现了一个崩溃，但 Redis 具有自动重启系统，重启了进程，因为关闭了持久化，节点重启后只有一个空的数据集。</li><li>节点 B 和 C 从节点 A 进行复制，现在节点 A 是空的，所以节点 B 和 C 上的复制数据也会被删除。</li><li>当在高可用系统中使用 Redis Sentinel，关闭主服务器的持久化，并且运行自动重启后，这种情况是很危险的。比如主服务器可能在很短的时间就完成了重启，以至于 Sentinel 都无法检测到这次失败，那么上面说的这种失败的情况就发生了。</li></ul><p>如果数据比较重要，并且在使用主从复制时关闭了主服务器持久化功能的场景中，都应该禁止实例自动重启。</p><h3 id="为什么还会有从库的从库的设计？"><a href="#为什么还会有从库的从库的设计？" class="headerlink" title="为什么还会有从库的从库的设计？"></a>为什么还会有从库的从库的设计？</h3><p>通过分析主从库间的第一次数据同步的过程，你可以看到，一次全量复制中，对于主库来说，需要完成两个耗时的操作：<strong>生成 RDB 文件和传输 RDB 文件。</strong></p><p>如果从库数量过多，而且都要和主库进行全量复制的话，就会导致主库忙于 fork 子进程生成 RDB 文件，进行数据全量复制。fork 这个操作会阻塞主进程处理正常请求，从而导致主库响应应用程序的请求速度变慢。此外，传输 RDB 文件也会占用主库的网络宽带，同样会给主库的资源使用带来压力。那么，有没有好的解决方法可用分担主库压力呢？</p><p>其实是有的，这就是“主-从-从”模式。</p><p>在刚才的介绍的主从库模式中，所有的从库都是和主库连接，所有的全量复制也都是和主库进行的。现在，我们可用通过“主-从-从”模式<strong>将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上。</strong></p><p>简单来说，我们在部署主从集群的时候，可用手动选择一个从库（比如选择内存资源配置较高的从库），用于级联其他非从库。然后，我们可用再选择一些从库（例如三分之一的从库），在这些从库上执行如下命令，使它们和刚才所选的从库，建立起主从关系。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof 所选从库的IP 6379</span><br></pre></td></tr></table></figure><p>这样一来，从库就会知道，在进行同步时，不用再和主库进行交互了，只要和级联的从库进行写操作同步就行了，这样可用减轻主库上的压力，如下图所示：</p><p><img src="/home/zzt/blog/source/_posts/更深入理解Redis复制/1.jpg" class="lazyload" data-srcset="/home/zzt/blog/source/_posts/更深入理解Redis复制/1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>级联的“主-从-从”模式好了，到这里，我们了解了主从库间通过全量复制实现数据同步的过程，以及通过“主-从-从”模式分担主库压力的方式。那么，一旦主库完成了全量复制，它们之间就会一直维护一个网络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库，这个过程也称为基于长连接的命令传播，可用避免频繁建立连接的开销。</p><h3 id="读写分离及其中的问题"><a href="#读写分离及其中的问题" class="headerlink" title="读写分离及其中的问题"></a>读写分离及其中的问题</h3><p>在主从复制基础上实现的读写分离，可用实现 Redis 的读负载均衡：由主节点提高写服务，由一个或多个从节点提供读服务（多个从节点既可以提高数据冗余程度，也可以最大化读负载能力）；在读负载较大的应用场景下，可用大大提高 Redis 服务器的并发量。下面介绍在使用 Redis 读写分离时，需要注意的问题。</p><ul><li><strong>延迟与不一致问题</strong></li></ul><p>前面已经讲到，由于主从复制的命令传播是异步的，延迟与数据的不一致不可避免。如果应用对数据不一致的接受程度较低，可能的优化措施包括：优化主从节点之间的网络环境（如在同机房部署）；监控主从节点延迟（通过 offset）判断，如果节点延迟过大，通知应用不再通过该节点读取数据；使用集群同步扩展写负载和读复制等。</p><ul><li><strong>数据过期问题</strong></li></ul><p>在单机 Redis 中，存在两种删除策略：</p><ul><li><code>惰性删除</code>：服务器不会主动删除数据，只有当客户查询某个数据时，服务器判断该数据是否过期，如果过期则删除。</li><li><code>定期删除</code>：服务器执行定时任务删除过期数据，但是考虑到内存和 CPU 的折中（删除会释放内存，但是频繁的删除操作对 CPU 不友好），该删除的频率和执行时间都受到了限制。</li></ul><p>在主从复制场景下，为了主从节点的数据一致性，从节点不会主动删除数据，而是由主节点控制从节点中过期数据的删除。由于主节点的惰性删除和定期删除策略，都不能保证主节点及时对过期数据执行删除操作，因此，当客户端通过 Redis 从节点读取数据时，很容易读到已经过期的数据。</p><p>Redis 3.2 中，从节点在读取数据时，增加了对数据是否过期的判断：如果该数据已经过期，则不返回给客户端；</p><ul><li><strong>故障切换问题</strong></li></ul><p>在没有使用哨兵的读写分离场景下，应用针对读和写分别连接不同的 Redis 节点；当主节点或从节点出现问题而发生变更时；需要及时修改应用程序读写 Redis 数据的连接；连接的切换可以手动进行，或者自己写监控程序进行切换，但前者响应慢、容易出错，后者实现复杂，成本都不算低。</p><ul><li><strong>总结</strong></li></ul><p>在使用读写分离之前，可用考虑其他方法增加 Redis 的读负载能力：如尽量优化主节点（减少慢查询、减少持久化等其他情况带来的阻塞等）提高负载能力；使用 Redis 集群同时提高读负载能力和写负载能力等。如果使用读写分离，可以使用哨兵，使主节点的故障切换尽可能自动化，并减少对应用程序的侵入。</p>]]></content>
    
    
    <summary type="html">通过几个问题更加深入的理解Redis的主从复制。</summary>
    
    
    
    <category term="Redis" scheme="https://tang7o.cn/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://tang7o.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis复制</title>
    <link href="https://tang7o.cn/2021/11/04/Redis%E5%A4%8D%E5%88%B6/"/>
    <id>https://tang7o.cn/2021/11/04/Redis%E5%A4%8D%E5%88%B6/</id>
    <published>2021-11-04T00:57:39.000Z</published>
    <updated>2022-04-13T13:31:48.310Z</updated>
    
    <content type="html"><![CDATA[<p>在 Redis 中，用户可以通过执行 <code>SLAVEOF</code> 命令或者设置 slaveof 选项，让一个服务器去复制另一个服务器，我们称呼被复制的服务器为主服务器，而复制主服务器的服务器被称为从服务器。</p><p>命令如下：</p><p><code>SLAVEOF host port</code></p><h2 id="复制功能的实现"><a href="#复制功能的实现" class="headerlink" title="复制功能的实现"></a>复制功能的实现</h2><h3 id="Redis-2-8前"><a href="#Redis-2-8前" class="headerlink" title="Redis 2.8前"></a>Redis 2.8前</h3><p>Redis 复制功能分为同步（sync）和命令传播（command propagate）两个操作：</p><ul><li>同步：将从服务器的数据库状态更新至主服务器的当前所处的数据库状态。</li><li>命令传播：在主服务器的数据库状态被修改，导致主从服务器的数据库状态不一致时，让主从服务器的数据库重新回到一致的状态。</li></ul><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>从服务器对主服务器的同步操作需要通过向主服务器发送 <code>SYNC</code> 命令来完成，以下是 <code>SYNC</code>命令的执行过程：</p><ol><li>从服务器向主服务器发送 <code>SYNC</code> 命令。</li><li>收到 <code>SYNC</code> 命令的主服务器执行 <code>BGSAVE</code> 命令，在后台生成一个 RDB 文件，并使用一个缓冲区记录从现在开始执行的所有<strong>写命令</strong>。</li><li>当主服务器的 <code>BGSAVE</code> 命令执行完成后，主服务器会将 <code>BGSAVE</code> 命令产生的 RDB 文件发送给从服务器，从服务器接收并载入这个 RDB 文件，将自己的数据库状态更新至<strong>主服务器执行 <code>BGSAVE</code> 时的数据库状态</strong>。</li><li>主服务器将记录在缓冲区中的命令发送给从服务器，从服务器执行这些<strong>写命令</strong>，将自己的数据库状态更新至<strong>主服务器当前的数据库状态</strong>。</li></ol><h4 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h4><p>主服务器会将自己执行的<strong>写命令</strong>，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行来相同的写命令后，主从服务器将再次回到一致状态。</p><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>在 Redis 2.8 以前，从服务器对主服务器的复制可以分为一下两种情况：</p><ul><li>初次复制：从服务器以前没有复制过任何服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同。</li><li>断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动连接重新连上了主服务器，并继续复制主服务器。</li></ul><p>在 Redis 2.8 以前，断线后重复制和初次复制使用相同的方法来实现，这就意味着断线后重复制要再次执行一遍 <code>SYNC</code> 命令。这是十分消耗资源的。（断线时间较短时，断线后重复制仅需要复制断线期间的命令即可，完全没有必要重新复制一遍）</p><blockquote><p><code>SYNC</code> 命令是一个十分消耗资源的操作</p><ol><li>主服务器需要执行 <code>BGSAVE</code> 命令来生成 RDB 文件，这个命令会消耗主服务器大量的 CPU、内存和磁盘I/O 资源。</li><li>主服务器需要将生成的 RDB 文件发送给从服务器，会消耗大量的网络资源，并对主服务器响应命令请求的时间产生影响。</li><li>从服务器需要载入 RDB 文件，在载入期间，从服务器会因为阻塞而无法处理命令请求。</li></ol></blockquote><h3 id="Redis-2-8后"><a href="#Redis-2-8后" class="headerlink" title="Redis 2.8后"></a>Redis 2.8后</h3><p>为了解决旧版复制功能在处理断线后重复制情况时的抵消问题，Redis 从 2.8 版本开始，使用 <code>PSYNC</code> 代替 <code>SYNC</code> 命令来执行复制时的同步操作。</p><p><code>PSYNC</code> 具有<strong>完整重同步</strong>和<strong>部分重同步</strong>两种模式：</p><ul><li>完整重同步：用于处理初次复制情况，和 <code>SYNC</code> 命令执行步骤基本相同。</li><li>部分重同步：用于处理断线后重复制情况，当从服务器段吸纳后重新连接主服务器时，如果条件允许，主服务器可以将断线期间执行的写命令发给从服务器，从服务器只要接收并执行这些命令，就可以将数据库更新至主服务器当前所处的状态。</li></ul><h4 id="部分重同步的实现"><a href="#部分重同步的实现" class="headerlink" title="部分重同步的实现"></a>部分重同步的实现</h4><p>部分重同步功能由以下三个部分构成：</p><ul><li>主服务器的复制偏移量和从服务器复制偏移量。</li><li>主服务器的复制积压缓冲区。</li><li>服务器的运行 ID。</li></ul><h5 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h5><p>执行复制的双方分别维护一个复制偏移量：</p><ul><li>主服务器每次向从服务器传播 N 个字节的数据时，就将自己的复制偏移量 +N。</li><li>从服务器每次收到主服务器传来的 N 个字节的数据时，就将自己的复制偏移量 +N。</li></ul><p>通过对比主从服务器的复制偏移量，程序可以很容易的知道主从服务器是否处于一致状态：</p><ul><li>复制偏移量相同：处于一致状态。</li><li>复制偏移量不同：未处于一致状态。</li></ul><h5 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h5><p>由主服务器维护的一个固定长度的先进先出的队列，默认大小 1MB。</p><p>当主服务器进行命令传播时，不仅会将写命令发给所有从服务器还会将写命令入队到复制积压缓冲区。</p><p>因此，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列的每个字节记录相应的复制偏移量。</p><p>当从服务器重新连上主服务器时，重服务器会通过 <code>PSYNC</code> 命令将自己的复制偏移量 offset 发送给主服务器，主服务器根据这个复制偏移量来决定对从服务器执行何种同步：</p><ul><li>如果 offset 复制偏移量之后的数据仍在复制积压缓冲区中，那么执行部分重同步操作（将 offset 偏移量之后的数据发给从服务器）。</li><li>否则，执行完整重同步。</li></ul><p><strong>可以根据实际情况来调整复制加压缓冲区的大小。</strong></p><h5 id="服务器运行-ID"><a href="#服务器运行-ID" class="headerlink" title="服务器运行 ID"></a>服务器运行 ID</h5><p>除了复制偏移量和复制积压缓冲区外，实现部分重同步还需要用到服务器运行 ID：</p><ul><li>每个 Redis 服务器都有自己的运行 ID。</li><li>运行 ID 在服务器启动时自动生成，由 40 个随机的十六进制组成。</li></ul><p>从服务器对主服务器进行初次复制时，从服务器会将主服务器的运行 ID 保存下来。当从服务器断线并重连上一个服务器时，从服务器会向当前连接的主服务器发送保存的运行 ID:</p><ul><li>从服务器保存的运行 ID 和主服务器的运行 ID 相同，尝试执行部分重同步。</li><li>相反，从服务器保存的运行 ID 和主服务器的运行 ID 不同，执行完整重同步。</li></ul><h4 id="PSYNC-命令的实现"><a href="#PSYNC-命令的实现" class="headerlink" title="PSYNC 命令的实现"></a>PSYNC 命令的实现</h4><p><code>PSYNC</code> 命令的调用方法有两种：</p><ul><li>如果从服务器之前没有复制过任何主服务器，或者之前执行过 <code>SLAVEOF no one</code> 命令，那么从服务器在开始一次新的复制时将向主服务器发送 <code>PSYNC ? -1</code> 命令，主动请求主服务器进行完整同步。</li><li>相反地，如果从服务器已经复制过某个主服务器，那么从服务器在开始一次新的复制时将向主服务器发送 <code>PSYNC &lt;runid&gt; &lt;offset&gt;</code> 命令，其中 runid 是上一次复制的主服务器的运行 ID，offset 是从服务器当前的复制偏移量，接收到这条命令的主服务器将通过这两个参数来判断实现哪种同步操作。</li></ul><p>根据情况，接受到 <code>PSYNC</code> 命令的主服务器会向从服务器发送以下三种回复中的其中一种：</p><ul><li><code>+FULLRESYNC &lt;runid&gt; &lt;offset&gt;</code>回复：表示主服务器与从服务器执行完整重同步操作：其中 runid 是主服务器的运行 ID，从服务器会将这个 ID 保存起来，在下次发送 <code>PSYNC</code> 命令的时候使用；offset 是主服务器当前的复制偏移量，从服务器会将这个值作为自己的初始化偏移量。</li><li><code>+CONTINUE</code> 回复：表示主服务器将与从服务器进行部分重同步，从服务器只需要等着主服务器将自己缺少的哪部分数据发送过来就可以了。</li><li><code>-ERR</code> 回复：表示主服务器的版本低于 Redis 2.8，它无法识别 <code>PSYNC</code> 命令，从服务器将向主服务器发送 <code>SYNC</code> 命令，并与主服务器执行完整同步。</li></ul><p><img src="1.png" class="lazyload" data-srcset="1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>]]></content>
    
    
    <summary type="html">讲述了 Redis 2.8 之前和 Redis 2.8 之后的复制功能的实现。</summary>
    
    
    
    <category term="Redis" scheme="https://tang7o.cn/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://tang7o.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>TCP可靠性</title>
    <link href="https://tang7o.cn/2021/10/26/TCP%E5%8F%AF%E9%9D%A0%E6%80%A7/"/>
    <id>https://tang7o.cn/2021/10/26/TCP%E5%8F%AF%E9%9D%A0%E6%80%A7/</id>
    <published>2021-10-26T07:34:39.000Z</published>
    <updated>2022-04-13T13:31:48.429Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，TCP 协议传输的特点主要就是面向字节流、传输可靠、面向连接。这篇文章，我们讨论以下 TCP 如何确保传输的可靠性的。</p><h2 id="确保传输可靠性的方式"><a href="#确保传输可靠性的方式" class="headerlink" title="确保传输可靠性的方式"></a>确保传输可靠性的方式</h2><p>TCP 协议保证数据传输可靠性的方式主要有：</p><ul><li>校验和</li><li>序列号</li><li>确认应答</li><li>超时重传</li><li>连接管理</li><li>流量控制</li><li>拥塞控制</li></ul><h3 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h3><p>TCP 检验和的计算与 UDP 一样，在计算时要加上 12byte 的伪首部，检验范围包括 TCP 首部及数据部分，但是 UDP 的检验和字段为可选的，而 TCP 中是必须有的。</p><p>计算方法为：在发送方将整个报文段分为多个 16 位的段，然后将所有段进行反码相加，将结果存放在检验和字段中，接收方用相同的方法进行计算，如最终结果为检验字段所有位是全 1 则正确（UDP 中也是全为 1 则正确），否则存在错误。</p><p><strong>示例：</strong></p><p>为了方便以 4 位为例：</p><p>发送端计算：</p><ul><li><p>数据：1000 0100 、校验和：0000</p></li><li><p>反码：0111 1011         1111</p></li><li>叠加：0111+1011+1111 = 0010 0001，高于 4 位的，叠加到低 4 位 0001 + 0010 = 0011 即为校验和。</li></ul><p>接收端计算：</p><ul><li>数据：1000  0100 、校验和 0011</li><li>反码：0111  1011        1100</li><li>叠加：0111+1011+1100 = 0001 1110，高于 4 位的，叠加到低 4 位 0001 + 1110 = 1111。全为1，则正确。</li></ul><h3 id="确认应答与序列号"><a href="#确认应答与序列号" class="headerlink" title="确认应答与序列号"></a>确认应答与序列号</h3><p>序列号：TCP 传输时将每个字节的数据都进行了编号，这就是序列号。</p><p>序列号的作用：</p><ul><li>保证可靠性（当接收到的数据总少了某个序号的数据时，能马上知道）。</li><li>保证数据的按序到达。</li><li>提高效率，可实现多次发送，一次确认。</li><li>去除重复数据</li></ul><p>确认应答：TCP 传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送 ACK 报文。这个 ACK 报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。</p><p><img src="1.png" class="lazyload" data-srcset="1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>在进行 TCP 传输时，由于确认应答与序列号机制，发送方发送一部分数据后，都会等待接收方发送的 ACK 报文，并且解析报文，判断数据发送是否成功。但是由于一些原因，发送方可能接收不到 ACK 报文：</p><p>情况一：</p><p><img src="2.png" class="lazyload" data-srcset="2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>情况二：</p><p><img src="3.png" class="lazyload" data-srcset="3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p><strong>重传时间如何确定？</strong></p><p>在 Linux 中，超时以 $500ms$ 为单位进行控制，每次判定超时重发的超时时间都是 $500ms$ 的整数倍。其规律为：如果重发一次仍得不到应答，就等待 $2<em>500ms$ 后再进行重传，如果仍然得不到应答就等待 $4</em>500ms$ 后重传，依次类推，以指数形式递增，重传次数累计到一定次数后，TCP 认为网络或对端主机出现异常，就会强行关闭连接。</p><h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p>连接管理机制即TCP建立连接时的三次握手和断开连接时的四次挥手。</p><p><a href="https://tang7o.cn/2021/06/09/TCP/">TCP文章</a>中有详细结束，在此不在赘述。</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>接收端处理数据的速度是有限的，如果发送方发送数据的速度过快，超过接收端的处理能力，就会造成丢包，继而引起丢包重传等一系列反应。</p><p>因此 TCP 支持根据接收端的处理能力，来决定发送端的发送速度，这个机制叫做流量控制。</p><p>在 <a href="https://tang7o.cn/2021/06/09/TCP/">TCP 报文段首部</a>中有一个 16 位窗口长度，当接收端接收到发送方的数据后，在应答报文 ACK 中就将自身缓冲区的剩余大小，放入 16 窗口大小中。这个大小随数据传输情况而变，窗口越大，网络吞吐量越高，而一旦接收方发现自身的缓冲区快满了，就将窗口设置为更小的值通知发送方。如果缓冲区满，就将窗口置为 0，发送方收到后就不再发送数据，但是需要定期发送一个窗口探测数据段，使接收端把窗口大小告诉发送端。</p><p><img src="4.png" class="lazyload" data-srcset="4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p><strong>注意：窗口大小不完全受 16 位窗口大小限制，在TCP首部 40 字节选项中还包含一个窗口扩大因子 M，实际窗口大小是窗口字段的值左移 M 位。</strong></p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>TCP 传输的过程中，发送端开始发送数据的时候，如果刚开始就发送大量的数据，那么就可能造成一些问题。网络可能在开始的时候就很拥堵，如果给网络中在扔出大量数据，那么这个拥堵就会加剧。拥堵的加剧就会产生大量的丢包，就对大量的超时重传，严重影响传输。</p><p>因此 TCP 引入了慢启动的机制，在开始发送数据的时候，先发送少量的数据探路，探清当前网络拥堵的状态后，在决定按照多大的数度发送数据。这时候引入了一个叫做<strong>拥塞窗口</strong>（cwnd）的概念。每次收到一个 ACK 应答，拥塞窗口加1，在发送数据之前，首先将拥塞窗口与接收端反馈的窗口大小比对，取较小的值作为实际发送的窗口。</p><p>TCP 的四种拥塞控制算法：</p><ol><li>慢开始</li><li>拥塞避免</li><li>快重传</li><li>快恢复</li></ol><h4 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h4><p>假设当前发送方拥塞窗口 cwnd 的值为 1，发送方当前发送一个数据报文段，接收方收到该数据报文段后，给发送方回复一个确认报文段，发送方收到该确认报文后，将拥塞窗口的值变为 2，发送方此时可以连续发送两个数据报文段，接收方收到该数据报文段后，给发送方返回 2 个确认报文段，发送方收到这两个确认报文后，将拥塞窗口的值加 2 变为 4，发送方此时可连续发送 4 个报文段，接收方收到 4 个报文段后，给发送方回复 4 个确认报文，发送方收到确认报文后，将拥塞窗口的值加 4 变为 8，发送方此时可以连续发送 8 个数据报文段…</p><p>当前的拥塞窗口 cwnd 的值已经等于慢开始门限值 ssthresh，之后改用拥塞避免算法。</p><p><img src="5.png" class="lazyload" data-srcset="5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>此时每个传输轮次，拥塞窗口 cwnd 只能线性加一，而不是像慢开始算法时，每个传输轮次，拥塞窗口 cwnd 按指数增长。同理：16+1… 直至到达 24，假设 24 个报文段在传输过程中丢失 4 个，接收方只收到 20 个报文段，给发送方依次回复 20 个确认报文段，一段时间后，丢失的 4 个报文段的重传计时器超时了，发送发判断可能出现拥塞，更改 $ssthresh = cwnd / 2、cwnd = 1$ 并重新开始慢开始算法。</p><h4 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h4><p><img src="6.png" class="lazyload" data-srcset="6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>快重传算法规定，发送方只要一连收到三个重复确认（一共是四个，第一个 ACK 2 是正常的）就应当立即重传对方尚未收到的报文段 2，而不必继续等待为 2 设置的重传计时器到期进行超时重传。</p><p>因为超时重传需要重新开始慢启动算法，cwnd 重置未 1，太影响效率。</p><p><a href="https://www.zhihu.com/question/21789252">为什么是三个重复确认？</a></p><h4 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h4><p>与<strong>快重传</strong>配合使用：</p><ol><li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限 ssthresh 减半。这是为了预防网络发生拥塞。请注意，接下去不执行慢开始算法。</li><li>由于发送方现在认为网络很可能没有发生拥塞（如果网络发生了严重的拥塞，就不会一连有好几个报文段连续到达接收方，也就不会导致接收方连续发送重复确认），因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口 cwnd 现在不设置为 1），而是$cwnd = cwnd/2、sshthresh = cwnd$，然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。</li></ol><p><img src="7.png" class="lazyload" data-srcset="7.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>上图给出了快重传和快恢复的示意图，并标明了“TCP Reno版本”，这是目前使用得很广泛的版本。</p><p>图中还画出了已经废弃不用的虚线部分（TCP Tahoe 版本）。请注意它们的区别就是：新的 TCP Reno 版本在快重传之后采用快恢复算法而不是采用慢开始算法。</p><p>参考文章：</p><p><a href="https://blog.csdn.net/xuzhangze/article/details/80490362">TCP可靠性的保证机制总结</a></p><p><a href="https://zhuanlan.zhihu.com/p/261096328">TCP 面试系列之快重传与快恢复</a></p><p><a href="https://blog.csdn.net/whgtheone/article/details/80983882">TCP的快速重传机制</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;众所周知，TCP 协议传输的特点主要就是面向字节流、传输可靠、面向连接。这篇文章，我们讨论以下 TCP 如何确保传输的可靠性的。&lt;/p&gt;
&lt;h2 id=&quot;确保传输可靠性的方式&quot;&gt;&lt;a href=&quot;#确保传输可靠性的方式&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="网络" scheme="https://tang7o.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="TCP" scheme="https://tang7o.cn/categories/%E7%BD%91%E7%BB%9C/TCP/"/>
    
    
    <category term="TCP" scheme="https://tang7o.cn/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>CAS</title>
    <link href="https://tang7o.cn/2021/10/23/CAS/"/>
    <id>https://tang7o.cn/2021/10/23/CAS/</id>
    <published>2021-10-23T07:03:59.000Z</published>
    <updated>2022-04-13T13:31:47.951Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h3><p>CAS 的全称为 Compare-And-Swap，直译就是对比交换。是一条 CPU 的原子指令，其作用是让 CPU 先进行比较两个值是否相等，然后原子地更新某个位置的值，经过调查发现，其实现方式是基于硬件平台的汇编指令，就是说 CAS 是靠硬件实现的，JVM 只是封装了汇编调用，那些 AtomicInteger 类便是使用了这些封装后的接口。  简单解释：CAS 操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先比较下在旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。</p><p>CAS 操作是原子性的，所以多线程并发使用 CAS 更新数据时，可以不使用锁。JDK 中大量使用了CAS 来更新数据而防止加锁（synchronized 重量级锁）来保持原子更新。</p><p>相信 sql 大家都熟悉，类似 sql 中的条件更新一样：<code>update set id=3 from table where id=2</code>。因为单条 sql 执行具有原子性，如果有多个线程同时执行此 sql 语句，只有一条能更新成功。</p><h3 id="CAS使用示例"><a href="#CAS使用示例" class="headerlink" title="CAS使用示例"></a>CAS使用示例</h3><p>如果不使用 CAS，在高并发下，多线程同时修改一个变量的值我们需要 synchronized 加锁（可能有人说可以用 Lock 加锁，Lock 底层的 AQS 也是基于 CAS 进行获取锁的）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java 中为我们提供了 AtomicInteger 原子类（底层基于 CAS 进行更新数据的），不需要加锁就在多线程并发场景下实现数据的一致性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i.addAndGet(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CAS-问题"><a href="#CAS-问题" class="headerlink" title="CAS 问题"></a>CAS 问题</h3><p>CAS 方式为乐观锁，synchronized 为悲观锁。因此使用 CAS 解决并发问题通常情况下性能更优。</p><p>但使用 CAS 方式也会有几个问题：</p><h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><p>因为 CAS 需要在操作值的时候，检查值有没有发生变化，比如没有发生变化则更新，但是如果一个值原来是 A，变成了 B，又变成了 A，那么使用 CAS 进行检查时则会发现它的值没有发生变化，但是实际上却变化了。</p><p>ABA 问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加 1，那么 A-&gt;B-&gt;A 就会变成 1A-&gt;2B-&gt;3A。</p><p>从 Java 1.5 开始，JDK 的 Atomic 包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。这个类的 compareAndSet 方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><h4 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h4><p>自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的执行开销。如果 JVM 能支持处理器提供的 pause 指令，那么效率会有一定的提升。pause 指令有两个作用：第一，它可以延迟流水线执行命令（de-pipeline），使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；第二，它可以避免在退出循环的时候因内存顺序冲突（Memory Order Violation）而引起 CPU 流水线被清空（CPU Pipeline Flush），从而提高 CPU 的执行效率。</p><h4 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h4><p>当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。</p><p>还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量 <code>i = 2，j = a</code>，合并一下 <code>ij = 2a</code>，然后用 CAS 来操作 ij。</p><p>从Java 1.5开始，JDK 提供了 AtomicReference 类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行 CAS 操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是CAS&quot;&gt;&lt;a href=&quot;#什么是CAS&quot; class=&quot;headerlink&quot; title=&quot;什么是CAS&quot;&gt;&lt;/a&gt;什么是CAS&lt;/h3&gt;&lt;p&gt;CAS 的全称为 Compare-And-Swap，直译就是对比交换。是一条 CPU 的原子指令，其作用是让</summary>
      
    
    
    
    <category term="Java" scheme="https://tang7o.cn/categories/Java/"/>
    
    <category term="并发" scheme="https://tang7o.cn/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="Java" scheme="https://tang7o.cn/tags/Java/"/>
    
    <category term="并发" scheme="https://tang7o.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>FutureTask</title>
    <link href="https://tang7o.cn/2021/10/20/FutureTask/"/>
    <id>https://tang7o.cn/2021/10/20/FutureTask/</id>
    <published>2021-10-20T10:41:06.000Z</published>
    <updated>2022-04-13T13:31:47.997Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FutureTask-简介"><a href="#FutureTask-简介" class="headerlink" title="FutureTask 简介"></a>FutureTask 简介</h2><p>FutureTask 为 Future 提供了基础实现，如获取任务执行结果(get)和取消任务(cancel)等。如果任务尚未完成，获取任务执行结果时将会阻塞。一旦执行结束，任务就不能被重启或取消(除非使用runAndReset执行计算)。FutureTask 常用来封装 Callable 和 Runnable，也可以作为一个任务提交到线程池中执行。除了作为一个独立的类之外，此类也提供了一些功能性函数供我们创建自定义 task 类使用。FutureTask 的线程安全由CAS来保证。</p><h2 id="FutureTask-类关系"><a href="#FutureTask-类关系" class="headerlink" title="FutureTask 类关系"></a>FutureTask 类关系</h2><p><img src="1.png" class="lazyload" data-srcset="1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>可以看到,FutureTask 实现了 RunnableFuture 接口，则 RunnableFuture 接口继承了 Runnable 接口和 Future 接口，所以 FutureTask 既能当做一个 Runnable 直接被 Thread 执行，也能作为 Future 用来得到 Callable 的计算结果。</p><h2 id="FutureTask-源码解析"><a href="#FutureTask-源码解析" class="headerlink" title="FutureTask 源码解析"></a>FutureTask 源码解析</h2><h3 id="Callable-接口"><a href="#Callable-接口" class="headerlink" title="Callable 接口"></a>Callable 接口</h3><p>Callable 是个泛型接口，泛型 V 就是要 call() 方法返回的类型。对比 Runnable 接口，Runnable 不会返回数据也不能抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Future-接口"><a href="#Future-接口" class="headerlink" title="Future 接口"></a>Future 接口</h3><p>Future 接口代表异步计算的结果，通过 Future 接口提供的方法可以查看异步计算是否执行完成，或者等待执行结果并获取执行结果，同时还可以取消执行。Future 接口的定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>cancel()</code>:cancel() 方法用来取消异步任务的执行。如果异步任务已经完成或者已经被取消，或者由于某些原因不能取消，则会返回 false。如果任务还没有被执行，则会返回 true 并且异步任务不会被执行。如果任务已经开始执行了但是还没有执行完成，若 mayInterruptIfRunning 为 true，则会立即中断执行任务的线程并返回 true，若 mayInterruptIfRunning 为 false，则会返回 true 且不会中断任务执行线程。</li><li><code>isCanceled()</code>:判断任务是否被取消，如果任务在结束（正常执行结束或者执行异常结束）前被取消则返回 true，否则返回 false。</li><li><code>isDone()</code>:判断任务是否已经完成，如果完成则返回 true，否则返回 false。需要注意的是：任务执行过程中发生异常、任务被取消也属于任务已完成，也会返回 true。</li><li><code>get()</code>:获取任务执行结果，如果任务还没完成则会阻塞等待直到任务执行完成。如果任务被取消则会抛出 CancellationException 异常，如果任务执行过程发生异常则会抛出 ExecutionException 异常，如果阻塞等待过程中被中断则会抛出 InterruptedException 异常。</li><li><code>get(long timeout,Timeunit unit)</code>:带超时时间的 get() 版本，如果阻塞等待过程中超时则会抛出 TimeoutException 异常。</li></ul><h3 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//内部持有的callable任务，运行完毕后置空</span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从get()中返回的结果或抛出的异常</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运行callable的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Treiber栈保存等待线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NEW</span>          <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COMPLETING</span>   <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NORMAL</span>       <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCEPTIONAL</span>  <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span>    <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTING</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTED</span>  <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>其中需要注意的是 state 是 volatile 类型的，也就是说只要有任何一个线程修改了这个变量，那么其他所有的线程都会知道最新的值。7 种状态具体表示：</p><ul><li><code>NEW</code>：表示是个新的任务或者还没被执行完的任务。这是初始状态。</li><li><code>COMPLETING</code>：任务已经执行完成或者执行任务的时候发生异常，但是任务执行结果或者异常原因还没有保存到 outcome 字段（outcome 字段用来保存任务执行结果，如果发生异常，则用来保存异常原因）的时候，状态会从 NEW 变更到 COMPLETING。但是这个状态会时间会比较短，属于中间状态。</li><li><code>NORMAL</code>：任务已经执行完成并且任务执行结果已经保存到 outcome 字段，状态会从 COMPLETING 转换到 NORMAL。这是一个最终态。</li><li><code>EXCEPTIONAL</code>：任务执行发生异常并且异常原因已经保存到 outcome 字段中后，状态会从 COMPLETING 转换到 EXCEPTIONAL。这是一个最终态。</li><li><code>CANCELLED</code>：任务还没开始执行或者已经开始执行但是还没有执行完成的时候，用户调用了 cancel（false）方法取消任务且不中断任务执行线程，这个时候状态会从NEW转化为 CANCELLED 状态。这是一个最终态。</li><li><code>INTERRUPTING</code>：任务还没开始执行或者已经执行但是还没有执行完成的时候，用户调用了 cancel（true）方法取消任务并且要中断任务执行线程但是还没有中断任务执行线程之前，状态会从 NEW 转化为 INTERRUPTING。这是一个中间状态。</li><li><code>INTERRUPTED</code>：调用 interrupt() 中断任务执行线程之后状态会从 INTERRUPTING 转换到 INTERRUPTED。这是一个最终态。 有一点需要注意的是，所有值大于 COMPLETING 的状态都表示任务已经执行完成（任务正常执行完成，任务执行异常或者任务被取消）。</li></ul><p>各个状态之间的可能转换关系如下图所示:</p><p><img src="2.png" class="lazyload" data-srcset="2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li>FutureTask(Callable<V> callable)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.callable = callable;</span><br><span class="line">    <span class="built_in">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个构造函数会把传入的 Callable 变量保存在 this.callable 字段中，该字段定义为 <code>private Callable&lt;V&gt; callable</code>;用来保存底层的调用，在被执行完成以后会指向 null,接着会初始化 state 字段为 NEW。</p><ul><li>public FutureTask(Runnable runnable, V result)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Runnable runnable, V result)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="built_in">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个构造函数会把传入的 Runnable 封装成一个 Callable 对象保存在 callable 字段中，同时如果任务执行成功的话就会返回传入的 result。这种情况下如果不需要返回值的话可以传入一个 null。</p><p>顺带看下 Executors.callable() 这个方法，这个方法的功能是把 Runnable 转换成 Callable，代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="title function_">callable</span><span class="params">(Runnable task, T result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RunnableAdapter</span>&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里采用的是适配器模式，调用<code>RunnableAdapter&lt;T&gt;(task, result)</code>方法来适配，实现如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RunnableAdapter</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Runnable task;</span><br><span class="line">    <span class="keyword">final</span> T result;</span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">        <span class="built_in">this</span>.task = task;</span><br><span class="line">        <span class="built_in">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        task.run();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个适配器很简单，就是简单的实现了 Callable 接口，在 call() 实现中调用 Runnable.run() 方法，然后把传入的 result 作为任务的结果返回。</p><p>在 new 了一个 FutureTask 对象之后，接下来就是在另一个线程中执行这个 Task,无论是通过直接new 一个 Thread 还是通过线程池，执行的都是 run() 方法，接下来就看看 run() 方法的实现。</p><h3 id="核心方法-run"><a href="#核心方法-run" class="headerlink" title="核心方法 - run()"></a>核心方法 - run()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//新建任务，CAS替换runner为当前线程</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="type">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="literal">null</span>;</span><br><span class="line">                ran = <span class="literal">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);<span class="comment">//设置执行结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);<span class="comment">//处理中断逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>运行任务，如果任务状态为 NEW 状态，则利用 CAS 修改为当前线程。执行完毕调用 set(result) 方法设置执行结果。set(result) 源码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(V v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();<span class="comment">//执行完毕，唤醒等待线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先利用 cas 修改 state 状态为 COMPLETING，设置返回结果，然后使用 lazySet(UNSAFE.putOrderedInt) 的方式设置 state 状态为 NORMAL。结果设置完毕后，调用 finishCompletion() 方法唤醒等待线程，源码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">finishCompletion</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="literal">null</span>;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, waitersOffset, q, <span class="literal">null</span>)) &#123;<span class="comment">//移除等待线程</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;<span class="comment">//自旋遍历等待线程</span></span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="literal">null</span>;</span><br><span class="line">                    LockSupport.unpark(t);<span class="comment">//唤醒等待线程</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">WaitNode</span> <span class="variable">next</span> <span class="operator">=</span> q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="literal">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//任务完成后调用函数，自定义扩展</span></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    callable = <span class="literal">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>回到 run 方法，如果在 run 期间被中断，此时需要调用 handlePossibleCancellationInterrupt 方法来处理中断逻辑，确保任何中断(例如cancel(true))只停留在当前 run 或 runAndReset 的任务中，源码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePossibleCancellationInterrupt</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="comment">//在中断者中断线程之前可能会延迟，所以我们只需要让出CPU时间片自旋等待</span></span><br><span class="line">    <span class="keyword">if</span> (s == INTERRUPTING)</span><br><span class="line">        <span class="keyword">while</span> (state == INTERRUPTING)</span><br><span class="line">            Thread.yield(); <span class="comment">// wait out pending interrupt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心方法-get"><a href="#核心方法-get" class="headerlink" title="核心方法 - get()"></a>核心方法 - get()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取执行结果</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：FutureTask 通过 get() 方法获取任务执行结果。如果任务处于未完成的状态(<code>state &lt;= COMPLETING</code>)，就调用 awaitDone 方法(后面单独讲解)等待任务完成。任务完成后，通过 report 方法获取执行结果或抛出执行期间的异常。report 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回执行结果或抛出异常</span></span><br><span class="line"><span class="keyword">private</span> V <span class="title function_">report</span><span class="params">(<span class="type">int</span> s)</span> <span class="keyword">throws</span> ExecutionException &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CancellationException</span>();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutionException</span>((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心方法-awaitDone-boolean-timed-long-nanos"><a href="#核心方法-awaitDone-boolean-timed-long-nanos" class="headerlink" title="核心方法 - awaitDone(boolean timed, long nanos)"></a>核心方法 - awaitDone(boolean timed, long nanos)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">awaitDone</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    <span class="type">WaitNode</span> <span class="variable">q</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">queued</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">//自旋</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;<span class="comment">//获取并清除中断状态</span></span><br><span class="line">            removeWaiter(q);<span class="comment">//移除等待WaitNode</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="literal">null</span>)</span><br><span class="line">                q.thread = <span class="literal">null</span>;<span class="comment">//置空等待节点的线程</span></span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="literal">null</span>)</span><br><span class="line">            q = <span class="keyword">new</span> <span class="title class_">WaitNode</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            <span class="comment">//CAS修改waiter</span></span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, waitersOffset,</span><br><span class="line">                                                 q.next = waiters, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                removeWaiter(q);<span class="comment">//超时，移除等待节点</span></span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.parkNanos(<span class="built_in">this</span>, nanos);<span class="comment">//阻塞当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);<span class="comment">//阻塞当前线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：awaitDone 用于等待任务完成，或任务因为中断或超时而终止。返回任务的完成状态。函数执行逻辑如下：</p><p>如果线程被中断，首先清除中断状态，调用 removeWaiter 移除等待节点，然后抛出 InterruptedException。removeWaiter 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeWaiter</span><span class="params">(WaitNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.thread = <span class="literal">null</span>;<span class="comment">//首先置空线程</span></span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;          <span class="comment">// restart on removeWaiter race</span></span><br><span class="line">            <span class="comment">//依次遍历查找</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">WaitNode</span> <span class="variable">pred</span> <span class="operator">=</span> <span class="literal">null</span>, q = waiters, s; q != <span class="literal">null</span>; q = s) &#123;</span><br><span class="line">                s = q.next;</span><br><span class="line">                <span class="keyword">if</span> (q.thread != <span class="literal">null</span>)</span><br><span class="line">                    pred = q;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">                    pred.next = s;</span><br><span class="line">                    <span class="keyword">if</span> (pred.thread == <span class="literal">null</span>) <span class="comment">// check for race</span></span><br><span class="line">                        <span class="keyword">continue</span> retry;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, waitersOffset,q, s)) <span class="comment">//cas替换</span></span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果当前状态为结束状态(state &gt; COMPLETING),则根据需要置空等待节点的线程，并返回 Future 状态；</li><li>如果当前状态为正在完成(COMPLETING)，说明此时 Future 还不能做出超时动作，为任务让出 CPU 执行时间片；</li><li>如果 state 为 NEW，先新建一个 WaitNode，然后 CAS 修改当前 waiters；</li><li>如果等待超时，则调用 removeWaiter 移除等待节点，返回任务状态；如果设置了超时时间但是尚未超时，则park阻塞当前线程；</li><li>其他情况直接阻塞当前线程。</li></ul><h3 id="核心方法-cancel-boolean-mayInterruptIfRunning"><a href="#核心方法-cancel-boolean-mayInterruptIfRunning" class="headerlink" title="核心方法 - cancel(boolean mayInterruptIfRunning)"></a>核心方法 - cancel(boolean mayInterruptIfRunning)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span> &#123;</span><br><span class="line">    <span class="comment">//如果当前Future状态为NEW，根据参数修改Future状态为INTERRUPTING或CANCELLED</span></span><br><span class="line">    <span class="keyword">if</span> (!(state == NEW &amp;&amp;</span><br><span class="line">          UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW,</span><br><span class="line">              mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) &#123;<span class="comment">//可以在运行时中断</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> runner;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">                    t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, INTERRUPTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        finishCompletion();<span class="comment">//移除并唤醒所有等待线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：尝试取消任务。如果任务已经完成或已经被取消，此操作会失败。</p><ul><li>如果当前 Future 状态为 NEW，根据参数修改 Future 状态为 INTERRUPTING 或 CANCELLED。</li><li>如果当前状态不为 NEW，则根据参数 mayInterruptIfRunning 决定是否在任务运行中也可以中断。中断操作完成后，调用 finishCompletion 移除并唤醒所有等待线程。</li></ul>]]></content>
    
    
    <summary type="html">Future 表示了一个任务的生命周期，是一个可取消的异步运算，可以把它看作是一个异步操作的结果的占位符，它将在未来的某个时刻完成，并提供对其结果的访问。在并发包中许多异步任务类都继承自Future，其中最典型的就是 FutureTask。</summary>
    
    
    
    <category term="Java" scheme="https://tang7o.cn/categories/Java/"/>
    
    <category term="并发" scheme="https://tang7o.cn/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="Java" scheme="https://tang7o.cn/tags/Java/"/>
    
    <category term="并发" scheme="https://tang7o.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>线程池 ThreadPoolExecutor 详解</title>
    <link href="https://tang7o.cn/2021/10/18/Executors/"/>
    <id>https://tang7o.cn/2021/10/18/Executors/</id>
    <published>2021-10-18T01:47:33.000Z</published>
    <updated>2022-04-13T13:31:47.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要有线程池"><a href="#为什么要有线程池" class="headerlink" title="为什么要有线程池"></a>为什么要有线程池</h2><p>线程池能够对线程进行统一分配，调优和监控:</p><ul><li>降低资源消耗（线程无限制地创建，然后使用完毕后销毁）</li><li>提高响应速度（无须创建线程）</li><li>提高线程的可管理性</li></ul><h2 id="ThreadPoolExecutor-使用详解"><a href="#ThreadPoolExecutor-使用详解" class="headerlink" title="ThreadPoolExecutor 使用详解"></a>ThreadPoolExecutor 使用详解</h2><p>其实 java 线程池的实现原理很简单，说白了就是一个线程集合 workerSet 和一个阻塞队列 workQueue。当用户向线程池提交一个任务（也就是线程）时，线程池会先将任务放入 workQueue 中。workerSet 中的线程会不断的从 workQueue 中获取线程然后执行。当 workQueue 中没有任务的时候，worker 就会阻塞，直到队列中有任务了就取出来继续执行。</p><p><img src="1.png" class="lazyload" data-srcset="1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><h3 id="Execute-原理"><a href="#Execute-原理" class="headerlink" title="Execute 原理"></a>Execute 原理</h3><p>当一个任务提交至线程池之后:</p><ol><li>线程池首先当前运行的线程数量是否少于 corePoolSize。如果是，则创建一个新的工作线程来执行任务。如果都在执行任务，则进入 2。</li><li>判断 BlockingQueue 是否已经满了，倘若还没有满，则将线程放入 BlockingQueue。否则进入 3。</li><li>如果创建一个新的工作线程将使当前运行的线程数量超过 maximumPoolSize ，则交给 RejectedExecutionHandler 来处理任务，否则创建一个新的线程来执行任务。</li></ol><p>当 ThreadPoolExecutor 创建新线程时，通过 CAS 来更新线程池的状态 ctl.</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure><ul><li><code>corePoolSize</code> 线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于 corePoolSize。如果当前线程数为 corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的 <code>prestartAllCoreThreads()</code> 方法，线程池会提前创建并启动所有核心线程。</li><li><code>workQueue</code> 用来保存等待被执行的任务的阻塞队列. 在 JDK 中提供了如下阻塞队列: <ul><li><code>ArrayBlockingQueue</code>: 基于数组结构的有界阻塞队列，按 FIFO 排序任务；</li><li><code>LinkedBlockingQuene</code>: 基于链表结构的阻塞队列，按 FIFO 排序任务，吞吐量通常要高于 ArrayBlockingQuene；</li><li><code>SynchronousQuene</code>: 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 LinkedBlockingQuene；</li><li><code>PriorityBlockingQuene</code>: 具有优先级的无界阻塞队列；</li></ul></li></ul><p><code>LinkedBlockingQueue</code> 比 <code>ArrayBlockingQueue</code> 在插入删除节点性能方面更优，但是二者在 <code>put()</code>, <code>take()</code> 任务的时均需要加锁，<code>SynchronousQueue</code> 使用无锁算法，根据节点的状态判断执行，而不需要用到锁，其核心是 <code>Transfer.transfer()</code>.</p><ul><li><code>maximumPoolSize</code> 线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于 maximumPoolSize；当阻塞队列是无界队列，maximumPoolSize 则不起作用, 因为无法提交至核心线程池的线程会一直持续地放入 workQueue.</li><li><code>keepAliveTime</code> 线程空闲时的存活时间，即当线程没有任务执行时，该线程继续存活的时间；默认情况下，该参数只在线程数大于 corePoolSize 时才有用，超过这个时间的空闲线程将被终止；</li><li><code>unit</code> keepAliveTime 的单位。</li><li><code>threadFactory</code> 创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名。默认为 DefaultThreadFactory。</li><li><code>handler</code> 线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：<ul><li><code>AbortPolicy</code>：直接抛出异常，默认策略；</li><li><code>CallerRunsPolicy</code>：用调用者所在的线程来执行任务；</li><li><code>DiscardOldestPolicy</code>：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li><li><code>DiscardPolicy</code>：直接丢弃任务；</li></ul></li></ul><p>当然也可以根据应用场景实现 RejectedExecutionHandler 接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p><h3 id="三种类型"><a href="#三种类型" class="headerlink" title="三种类型"></a>三种类型</h3><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池的线程数量达 corePoolSize 后，即使线程池没有可执行任务时，也不会释放线程。</p><p>FixedThreadPool 的工作队列为无界队列 LinkedBlockingQueue （队列容量为 Integer.MAX_VALUE）, 这会导致以下问题:</p><ul><li>线程池里的线程数量不超过 corePoolSize,这导致了 maximumPoolSize 和 keepAliveTime 将会是个无用参数。</li><li>由于使用了无界队列, 所以 FixedThreadPool 永远不会拒绝, 即饱和策略失效。</li></ul><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化的线程池中只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行。</p><p>由于使用了无界队列，所以 SingleThreadPool 永远不会拒绝，即饱和策略失效。</p><h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池的线程数可达到 Integer.MAX_VALUE，即 2147483647，内部使用 SynchronousQueue 作为阻塞队列；和 newFixedThreadPool 创建的线程池不同， newCachedThreadPool 在没有任务执行时，当线程的空闲时间超过 keepAliveTime，会自动释放线程资源，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销；执行过程与前两种稍微不同:</p><ol><li><p>主线程调用 SynchronousQueue 的 offer() 方法放入 task，倘若此时线程池中有空闲的线程尝试读取  SynchronousQueue 的 task，即调用了 SynchronousQueue 的 poll()，那么主线程将该 task 交给空闲线程. 否则执行 2。</p></li><li><p>当线程池为空或者没有空闲的线程，则创建新的线程执行任务。</p></li><li><p>执行完任务的线程倘若在 60s 内仍空闲，则会被终止。因此长时间空闲的 CachedThreadPool 不会持有任何线程资源。</p></li></ol><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>遍历线程池中的所有线程，然后逐个调用线程的 interrupt 方法来中断线程.</p><h4 id="关闭方式-shutdown"><a href="#关闭方式-shutdown" class="headerlink" title="关闭方式 - shutdown"></a>关闭方式 - shutdown</h4><p>将线程池里的线程状态设置成 SHUTDOWN 状态，然后中断所有没有正在执行任务的线程。</p><h4 id="关闭方式-shutdownNow"><a href="#关闭方式-shutdownNow" class="headerlink" title="关闭方式 - shutdownNow"></a>关闭方式 - shutdownNow</h4><p>将线程池里的线程状态设置成STOP状态，然后停止所有正在执行或暂停任务的线程。只要调用这两个关闭方法中的任意一个，isShutDown() 返回 true。当所有任务都成功关闭了， isTerminated() 返回true。</p><h2 id="ThreadPoolExecutor-源码详解"><a href="#ThreadPoolExecutor-源码详解" class="headerlink" title="ThreadPoolExecutor 源码详解"></a>ThreadPoolExecutor 源码详解</h2><h3 id="几个关键属性"><a href="#几个关键属性" class="headerlink" title="几个关键属性"></a>几个关键属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个属性是用来存放 当前运行的 worker 数量以及线程池状态的</span></span><br><span class="line"><span class="comment">//int是 32 位的，这里把 int 的高 3 位拿来充当线程池状态的标志位,后 29 位拿来充当当前运行 worker 的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//存放任务的阻塞队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"><span class="comment">//worker的集合,用set来存放</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Worker&gt;();</span><br><span class="line"><span class="comment">//历史达到的worker数最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> largestPoolSize;</span><br><span class="line"><span class="comment">//当队列满了并且worker的数量达到maxSize的时候,执行具体的拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"><span class="comment">//超出coreSize的worker的生存时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> keepAliveTime;</span><br><span class="line"><span class="comment">//常驻worker的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> corePoolSize;</span><br><span class="line"><span class="comment">//最大worker的数量,一般当workQueue满了才会用到这个参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> maximumPoolSize;</span><br></pre></td></tr></table></figure><h3 id="内部状态"><a href="#内部状态" class="headerlink" title="内部状态"></a>内部状态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span>   <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><p>其中 AtomicInteger 变量 ctl 的功能非常强大: 利用低29位表示线程池中线程数，通过高3位表示线程池的运行状态:</p><ul><li><p><code>RUNNING: -1 &lt;&lt; COUNT_BITS</code>，即高3位为111，该状态的线程池会接收新任务，并处理阻塞队列中的任务；</p></li><li><p><code>SHUTDOWN:  0 &lt;&lt; COUNT_BITS</code>，即高3位为000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</p></li><li><p><code>STOP :  1 &lt;&lt; COUNT_BITS</code>，即高3位为001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；</p></li><li><p><code>TIDYING :  2 &lt;&lt; COUNT_BITS</code>，即高3位为010, 所有的任务都已经终止；</p></li><li><p><code>TERMINATED:  3 &lt;&lt; COUNT_BITS</code>，即高3位为011, terminated() 方法已经执行完成</p></li></ul><p><img src="2.png" class="lazyload" data-srcset="2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><h3 id="任务的执行"><a href="#任务的执行" class="headerlink" title="任务的执行"></a>任务的执行</h3><blockquote><p>execute –&gt; addWorker –&gt;runworker (getTask)</p></blockquote><p>线程池的工作线程通过 Woker 类实现，在 ReentrantLock 锁的保证下，把 Woker 实例插入到 HashSet 后，并启动 Woker 中的线程。 从 Woker 类的构造方法实现可以发现: 线程工厂在创建线程 thread 时，将 Woker 实例本身 this 作为参数传入，当执行 start 方法启动线程 thread 时，本质是执行了 Worker 的 runWorker 方法。 firstTask 执行完成之后，通过 getTask 方法从阻塞队列中获取等待的任务，如果队列中没有任务，getTask 方法会被阻塞并挂起，不会占用 cpu 资源；</p><h4 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute 方法"></a>execute 方法</h4><p>ThreadPoolExecutor.execute(task) 实现了 Executor.execute(task)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;  </span><br><span class="line">    <span class="comment">//workerCountOf获取线程池的当前线程数；小于corePoolSize，执行addWorker创建新线程执行command任务</span></span><br><span class="line">       <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// double check: c, recheck</span></span><br><span class="line">    <span class="comment">// 线程池处于RUNNING状态，把提交的任务成功放入阻塞队列中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// recheck and if necessary 回滚到入队操作前，即倘若线程池shutdown状态，就remove(command)</span></span><br><span class="line">        <span class="comment">//如果线程池没有RUNNING，成功从阻塞队列中删除任务，执行reject方法处理任务</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">//线程池处于running状态，但是没有线程，则创建线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 往线程池中创建新的线程失败，则reject任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为什么需要 double check 线程池的状态?</li></ul><p>在多线程环境下，线程池的状态时刻在变化，而 ctl.get() 是非原子操作，很有可能刚获取了线程池状态后线程池状态就改变了。判断是否将 command 加入 workque 是线程池之前的状态。倘若没有 double check，万一线程池处于非 running 状态(在多线程环境下很有可能发生)，那么 command 永远不会执行。</p><h4 id="addWorker-方法"><a href="#addWorker-方法" class="headerlink" title="addWorker 方法"></a>addWorker 方法</h4><p>从方法　execute　的实现可以看出: addWorker　主要负责创建新的线程并执行任务，线程池创建新线程执行任务时，需要获取全局锁:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    <span class="comment">// CAS更新线程池数量</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 线程池重入锁</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();  <span class="comment">// 线程启动，执行任务(Worker.thread(firstTask).start());</span></span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Worker-类的-runworker-方法"><a href="#Worker-类的-runworker-方法" class="headerlink" title="Worker 类的 runworker 方法"></a>Worker 类的 runworker 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>); <span class="comment">// 创建线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        runWorker(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>继承了 AQS 类，可以方便的实现工作线程的中止操作；</li><li>实现了 Runnable 接口，可以将自身作为一个任务在工作线程中执行；</li><li>当前提交的任务 firstTask 作为参数传入 Worker 的构造方法；</li></ul><p>一些属性还有构造方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行的线程,前面addWorker方法中就是直接通过启动这个线程来启动这个worker</span></span><br><span class="line"><span class="keyword">final</span> Thread thread;</span><br><span class="line"><span class="comment">//当一个worker刚创建的时候,就先尝试执行这个任务</span></span><br><span class="line">Runnable firstTask;</span><br><span class="line"><span class="comment">//记录完成任务的数量</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">    <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="comment">//创建一个Thread,将自己设置给他,后面这个thread启动的时候,也就是执行worker的run方法</span></span><br><span class="line">    <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>runWorker 方法是线程池的核心:</p><ul><li>线程启动之后，通过 unlock 方法释放锁，设置 AQS 的 state 为 0，表示运行可中断；</li><li>Worker 执行 firstTask 或从 workQueue 中获取任务:<ul><li>进行加锁操作，保证 thread 不被其他线程中断(除非线程池被中断)</li><li>检查线程池状态，倘若线程池处于中断状态，当前线程将中断。</li><li>执行 beforeExecute</li><li>执行任务的 run 方法</li><li>执行 afterExecute 方法</li><li>解锁操作</li></ul></li></ul><blockquote><p>通过 getTask 方法从阻塞队列中获取等待的任务，如果队列中没有任务，getTask 方法会被阻塞并挂起，不会占用 cpu 资源；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 先执行firstTask，再从workerQueue中取task(getTask())</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                    (Thread.interrupted() &amp;&amp;</span><br><span class="line">                    runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getTask-方法"><a href="#getTask-方法" class="headerlink" title="getTask 方法"></a>getTask 方法</h4><p>下面来看一下 getTask() 方法，这里面涉及到 keepAliveTime 的使用，从这个方法我们可以看出先吃池是怎么让超过 corePoolSize 的那部分 worker 销毁的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里一段代码是 keepAliveTime 起作用的关键:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br></pre></td></tr></table></figure><p>allowCoreThreadTimeOut 为 false，线程即使空闲也不会被销毁；倘若为 ture，在 keepAliveTime 内仍空闲则会被销毁。</p><p>如果线程允许空闲等待而不被销毁 timed == false，workQueue.take 任务: 如果阻塞队列为空，当前线程会被挂起等待；当队列中有任务加入时，线程被唤醒，take 方法返回任务，并执行；</p><p>如果线程不允许无休止空闲 timed == true, workQueue.poll 任务: 如果在 keepAliveTime 时间内，阻塞队列还是没有任务，则返回 null；</p><h3 id="任务的提交"><a href="#任务的提交" class="headerlink" title="任务的提交"></a>任务的提交</h3><p><img src="3.png" class="lazyload" data-srcset="3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><ol><li>submit 任务，等待线程池 execute。</li><li>执行 FutureTask 类的 get 方法时，会把主线程封装成 WaitNode 节点并保存在 waiters 链表中，并阻塞等待运行结果；</li><li>FutureTask 任务执行完成后，通过 UNSAFE 设置 waiters 相应的 waitNode 为 null，并通过 LockSupport 类unpark 方法唤醒主线程；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;String&gt; future = es.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;future result&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际业务场景中，Future 和 Callable 基本是成对出现的，Callable 负责产生结果，Future 负责获取结果。</p><ol><li>Callable 接口类似于 Runnable，只是 Runnable 没有返回值。</li><li>Callable 任务除了返回正常结果之外，如果发生异常，该异常也会被返回，即 Future 可以拿到异步执行任务各种结果；</li><li><code>Future.get</code> 方法会导致主线程阻塞，直到 Callable 任务执行完成；</li></ol><h4 id="submit方法"><a href="#submit方法" class="headerlink" title="submit方法"></a>submit方法</h4><p><code>AbstractExecutorService.submit()</code> 实现了 <code>ExecutorService.submit()</code> 可以获取执行完的返回值, 而 <code>ThreadPoolExecutor</code> 是 <code>AbstractExecutorService.submit()</code> 的子类，所以 submit 方法也是 <code>ThreadPoolExecutor</code> 的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// submit()在ExecutorService中的定义</span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;</span><br><span class="line"></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// submit方法在AbstractExecutorService中的实现</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 通过submit方法提交的Callable任务会被封装成了一个FutureTask对象。</span></span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 submit 方法提交的 Callable 任务会被封装成了一个 FutureTask 对象。通过 <code>Executor.execute()</code> 方法提交 FutureTask 到线程池中等待被执行，最终执行的是 FutureTask 的run方法；</p><h4 id="FutureTask对象"><a href="#FutureTask对象" class="headerlink" title="FutureTask对象"></a>FutureTask对象</h4><p><code>public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</code> 可以将 FutureTask 提交至线程池中等待被执行(通过 FutureTask 的 run 方法来执行)</p><ul><li>内部状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The run state of this task, initially NEW. </span></span><br><span class="line"><span class="comment">    * ...</span></span><br><span class="line"><span class="comment">    * Possible state transitions:</span></span><br><span class="line"><span class="comment">    * NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment">    * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment">    * NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment">    * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NEW</span>          <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COMPLETING</span>   <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NORMAL</span>       <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCEPTIONAL</span>  <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span>    <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTING</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTED</span>  <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>内部状态的修改通过 sun.misc.Unsafe 修改。</p><ul><li>get 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>内部通过 awaitDone 方法对主线程进行阻塞，具体实现如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">awaitDone</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    <span class="type">WaitNode</span> <span class="variable">q</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">queued</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="literal">null</span>)</span><br><span class="line">                q.thread = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="literal">null</span>)</span><br><span class="line">            q = <span class="keyword">new</span> <span class="title class_">WaitNode</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, waitersOffset,q.next = waiters, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.parkNanos(<span class="built_in">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果主线程被中断，则抛出中断异常；</li><li>判断 FutureTask 当前的 state，如果大于 COMPLETING，说明任务已经执行完成，则直接返回；</li><li>如果当前 state 等于 COMPLETING，说明任务已经执行完，这时主线程只需通过 yield 方法让出 cpu 资源，等待 state 变成 NORMAL；</li><li>通过 WaitNode 类封装当前线程，并通过 UNSAFE 添加到 waiters 链表；</li><li>最终通过 LockSupport 的 park 或 parkNanos 挂起线程；</li></ol><p>run 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW || !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset, <span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="type">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="literal">null</span>;</span><br><span class="line">                ran = <span class="literal">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureTask.run 方法是在线程池中被执行的，而非主线程</p><ol><li>通过执行 Callable 任务的 call 方法；</li><li>如果 call 执行成功，则通过 set 方法保存结果；</li><li>如果 call 执行有异常，则通过 setException 保存异常；</li></ol><h3 id="任务的关闭"><a href="#任务的关闭" class="headerlink" title="任务的关闭"></a>任务的关闭</h3><p>shutdown 方法会将线程池的状态设置为 SHUTDOWN,线程池进入这个状态后,就拒绝再接受任务,然后会将剩余的任务全部执行完。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//检查是否可以关闭线程</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//设置线程池状态</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">//尝试中断worker</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">            <span class="comment">//预留方法,留给子类实现</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">interruptIdleWorkers</span><span class="params">()</span> &#123;</span><br><span class="line">    interruptIdleWorkers(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">interruptIdleWorkers</span><span class="params">(<span class="type">boolean</span> onlyOne)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//遍历所有的worker</span></span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">            <span class="comment">//先尝试调用w.tryLock(),如果获取到锁,就说明worker是空闲的,就可以直接中断它</span></span><br><span class="line">            <span class="comment">//注意的是,worker自己本身实现了AQS同步框架,然后实现的类似锁的功能</span></span><br><span class="line">            <span class="comment">//它实现的锁是不可重入的,所以如果worker在执行任务的时候,会先进行加锁,这里tryLock()就会返回false</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shutdownNow 做的比较绝，它先将线程池状态设置为 STOP，然后拒绝所有提交的任务。最后中断左右正在运行中的 worker ,然后清空任务队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//检测权限</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">//中断所有的worker</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">//清空任务队列</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">interruptWorkers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//遍历所有worker，然后调用中断方法</span></span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            w.interruptIfStarted();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更深入理解"><a href="#更深入理解" class="headerlink" title="更深入理解"></a>更深入理解</h2><h3 id="为什么线程池不允许使用Executors去创建-推荐方式是什么"><a href="#为什么线程池不允许使用Executors去创建-推荐方式是什么" class="headerlink" title="为什么线程池不允许使用Executors去创建? 推荐方式是什么?"></a>为什么线程池不允许使用Executors去创建? 推荐方式是什么?</h3><p>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors 各个方法的弊端：</p><ul><li>newFixedThreadPool 和 newSingleThreadExecutor：主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至 OOM 。</li><li>newCachedThreadPool 和 newScheduledThreadPool：主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM。</li></ul><h4 id="推荐方式-1"><a href="#推荐方式-1" class="headerlink" title="推荐方式 1"></a>推荐方式 1</h4><p>首先引入：commons-lang3 包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BasicThreadFactory</span>.Builder().namingPattern(<span class="string">&quot;example-schedule-pool-%d&quot;</span>).daemon(<span class="literal">true</span>).build());</span><br></pre></td></tr></table></figure><h4 id="推荐方式-2"><a href="#推荐方式-2" class="headerlink" title="推荐方式 2"></a>推荐方式 2</h4><p>首先引入：com.google.guava 包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">namedThreadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>().setNameFormat(<span class="string">&quot;demo-pool-%d&quot;</span>).build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Common Thread Pool</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">200</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="number">1024</span>), namedThreadFactory, <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line"><span class="comment">// excute</span></span><br><span class="line">pool.execute(()-&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line"></span><br><span class="line"> <span class="comment">//gracefully shutdown</span></span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure><p>著作权归<a href="https://pdai.tech所有。">https://pdai.tech所有。</a> 链接：<a href="https://www.pdai.tech/md/java/thread/java-thread-x-juc-executor-ThreadPoolExecutor.html">https://www.pdai.tech/md/java/thread/java-thread-x-juc-executor-ThreadPoolExecutor.html</a></p><h4 id="推荐方式-3"><a href="#推荐方式-3" class="headerlink" title="推荐方式 3"></a>推荐方式 3</h4><p>spring 配置线程池方式：自定义线程工厂 bean 需要实现 ThreadFactory，可参考该接口的其它默认实现类，使用方式直接注入 bean 调用 execute(Runnable task) 方法即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userThreadPool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;corePoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;queueCapacity&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2000&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;threadFactory&quot;</span> <span class="attr">value</span>= <span class="string">threadFactory</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;rejectedExecutionHandler&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">&quot;rejectedExecutionHandler&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userThreadPool.execute(thread);</span><br></pre></td></tr></table></figure><h3 id="配置线程池需要考虑因素"><a href="#配置线程池需要考虑因素" class="headerlink" title="配置线程池需要考虑因素"></a>配置线程池需要考虑因素</h3><p>从任务的优先级，任务的执行时间长短，任务的性质(CPU 密集/ IO 密集)，任务的依赖关系这四个角度来分析。并且近可能地使用有界的工作队列。</p><p>性质不同的任务可用使用不同规模的线程池分开处理:</p><ul><li>CPU 密集型: 尽可能少的线程，Ncpu + 1</li><li>IO 密集型: 尽可能多的线程, Ncpu * 2，比如数据库连接池</li><li>混合型: CPU 密集型的任务与 IO 密集型任务的执行时间差别较小，拆分为两个线程池；否则没有必要拆分。</li></ul><h3 id="监控线程池的状态"><a href="#监控线程池的状态" class="headerlink" title="监控线程池的状态"></a>监控线程池的状态</h3><p>可以使用 ThreadPoolExecutor 以下方法:</p><ul><li><code>getTaskCount()</code> 返回计划执行的任务的大致总数。</li><li><code>getCompletedTaskCount()</code> 返回已完成执行的任务的大致总数。返回结果少于getTaskCount()。</li><li><code>getLargestPoolSize()</code>返回池中同时存在的最大线程数。返回结果小于等于maximumPoolSize</li><li><code>getPoolSize()</code> 返回池中当前的线程数。</li><li><code>getActiveCount()</code> 返回正在积极执行任务的线程的大致数目。</li></ul>]]></content>
    
    
    <summary type="html">关于 ThreadPoolExecutor 的讲解</summary>
    
    
    
    <category term="Java" scheme="https://tang7o.cn/categories/Java/"/>
    
    <category term="并发" scheme="https://tang7o.cn/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="Java" scheme="https://tang7o.cn/tags/Java/"/>
    
    <category term="并发" scheme="https://tang7o.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>synchronized</title>
    <link href="https://tang7o.cn/2021/10/15/synchronized/"/>
    <id>https://tang7o.cn/2021/10/15/synchronized/</id>
    <published>2021-10-15T07:45:23.000Z</published>
    <updated>2022-04-13T13:31:48.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Synchronized的使用"><a href="#Synchronized的使用" class="headerlink" title="Synchronized的使用"></a>Synchronized的使用</h2><p>在应用Sychronized关键字时需要把握如下注意点：</p><ul><li>一把锁只能同时被一个线程获取，没有获得锁的线程只能等待；</li><li>每个实例都对应有自己的一把锁（this）,不同实例之间互不影响；例外：锁对象是 *.class 以及 synchronized 修饰的是 static 方法的时候，所有对象公用同一把锁</li><li>synchronized 修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁</li></ul><h3 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h3><p>包括方法锁（默认锁对象为 this,当前实例对象）和同步代码块锁（自己指定锁对象）。</p><h4 id="代码块形式：手动指定锁定对象，也可是是this-也可以是自定义的锁"><a href="#代码块形式：手动指定锁定对象，也可是是this-也可以是自定义的锁" class="headerlink" title="代码块形式：手动指定锁定对象，也可是是this,也可以是自定义的锁"></a>代码块形式：手动指定锁定对象，也可是是this,也可以是自定义的锁</h4><ul><li>示例1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedObjectLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">SynchronizedObjectLock</span> <span class="variable">instence</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedObjectLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 同步代码块形式——锁为this,两个线程使用的锁是一样的,线程1必须要等到线程0释放了该锁后，才能执行</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instence);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instence);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我是线程Thread-0</span><br><span class="line">Thread-0结束</span><br><span class="line">我是线程Thread-1</span><br><span class="line">Thread-1结束</span><br></pre></td></tr></table></figure><ul><li>示例2</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedObjectLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">SynchronizedObjectLock</span> <span class="variable">instence</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedObjectLock</span>();</span><br><span class="line">    <span class="comment">// 创建2把锁</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">block1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">block2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这个代码块使用的是第一把锁，当他释放后，后面的代码块由于使用的是第二把锁，因此可以马上执行</span></span><br><span class="line">        <span class="keyword">synchronized</span> (block1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;block1锁,我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;block1锁,&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (block2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;block2锁,我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;block2锁,&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instence);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instence);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">block1锁,我是线程Thread-0</span><br><span class="line">block1锁,Thread-0结束</span><br><span class="line">block2锁,我是线程Thread-0　　// 可以看到当第一个线程在执行完第一段同步代码块之后，第二个同步代码块可以马上得到执行，因为他们使用的锁不是同一把</span><br><span class="line">block1锁,我是线程Thread-1</span><br><span class="line">block2锁,Thread-0结束</span><br><span class="line">block1锁,Thread-1结束</span><br><span class="line">block2锁,我是线程Thread-1</span><br><span class="line">block2锁,Thread-1结束</span><br></pre></td></tr></table></figure><h4 id="方法锁形式：synchronized修饰普通方法，锁对象默认为this"><a href="#方法锁形式：synchronized修饰普通方法，锁对象默认为this" class="headerlink" title="方法锁形式：synchronized修饰普通方法，锁对象默认为this"></a>方法锁形式：synchronized修饰普通方法，锁对象默认为this</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedObjectLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">SynchronizedObjectLock</span> <span class="variable">instence</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedObjectLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instence);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instence);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我是线程Thread-0</span><br><span class="line">Thread-0结束</span><br><span class="line">我是线程Thread-1</span><br><span class="line">Thread-1结束</span><br></pre></td></tr></table></figure><h3 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h3><p>指synchronize修饰静态的方法或指定锁对象为Class对象</p><h4 id="synchronize修饰静态方法"><a href="#synchronize修饰静态方法" class="headerlink" title="synchronize修饰静态方法"></a>synchronize修饰静态方法</h4><ul><li>示例1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedObjectLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">SynchronizedObjectLock</span> <span class="variable">instence1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedObjectLock</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">SynchronizedObjectLock</span> <span class="variable">instence2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedObjectLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// synchronized用在普通方法上，默认的锁就是this，当前实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// t1和t2对应的this是两个不同的实例，所以代码不会串行</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instence1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instence2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我是线程Thread-0</span><br><span class="line">我是线程Thread-1</span><br><span class="line">Thread-1结束</span><br><span class="line">Thread-0结束</span><br></pre></td></tr></table></figure><ul><li>示例2</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedObjectLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">SynchronizedObjectLock</span> <span class="variable">instence1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedObjectLock</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">SynchronizedObjectLock</span> <span class="variable">instence2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedObjectLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// synchronized用在静态方法上，默认的锁就是当前所在的Class类，所以无论是哪个线程访问它，需要的锁都只有一把</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instence1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instence2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我是线程Thread-0</span><br><span class="line">Thread-0结束</span><br><span class="line">我是线程Thread-1</span><br><span class="line">Thread-1结束</span><br></pre></td></tr></table></figure><h4 id="synchronized指定锁对象为Class对象"><a href="#synchronized指定锁对象为Class对象" class="headerlink" title="synchronized指定锁对象为Class对象"></a>synchronized指定锁对象为Class对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedObjectLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">SynchronizedObjectLock</span> <span class="variable">instence1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedObjectLock</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">SynchronizedObjectLock</span> <span class="variable">instence2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedObjectLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 所有线程需要的锁都是同一把</span></span><br><span class="line">        <span class="keyword">synchronized</span>(SynchronizedObjectLock.class)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是线程&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instence1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instence2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我是线程Thread-0</span><br><span class="line">Thread-0结束</span><br><span class="line">我是线程Thread-1</span><br><span class="line">Thread-1结束</span><br></pre></td></tr></table></figure><h2 id="Synchronized原理分析"><a href="#Synchronized原理分析" class="headerlink" title="Synchronized原理分析"></a>Synchronized原理分析</h2><h3 id="加锁和释放锁的原理"><a href="#加锁和释放锁的原理" class="headerlink" title="加锁和释放锁的原理"></a>加锁和释放锁的原理</h3><p>深入JVM看字节码，创建如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用javac命令进行编译生成.class文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;javac SynchronizedDemo2.java</span><br></pre></td></tr></table></figure><p>使用javap命令反编译查看.class文件的信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;javap -v SynchronizedDemo2.class</span><br></pre></td></tr></table></figure><p>得到如下的信息：</p><p><img src="1.png" class="lazyload" data-srcset="1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>关注红色方框里的 <code>monitorenter</code> 和 <code>monitorexit</code> 即可。</p><p><code>Monitorenter</code> 和 <code>Monitorexit</code> 指令，会让对象在执行，使其锁计数器加 1 或者减 1。每一个对象在同一时间只与一个 monitor (锁)相关联，而一个 monitor 在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的Monitor 锁的所有权的时候，<code>monitorenter</code> 指令会发生如下3中情况之一：</p><ul><li>monitor 计数器为 0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器 + 1，一旦 + 1，别的线程再想获取，就需要等待。</li><li>如果这个 monitor 已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成 2，并且随着重入的次数，会一直累加。</li><li>这把锁已经被别的线程获取了，等待锁释放。</li></ul><p><code>monitorexit</code> 指令：释放对于 monitor 的所有权，释放过程很简单，就是将 monitor 的计数器减 1，如果减完以后，计数器不是 0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成 0，则代表当前线程不再拥有该 monitor 的所有权，即释放锁。</p><p>下图表现了对象，对象监视器，同步队列以及执行线程状态之间的关系：</p><p><img src="2.png" class="lazyload" data-srcset="2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>该图可以看出，任意线程对 Object 的访问，首先要获得 Object 的监视器，如果获取失败，该线程就进入同步状态，线程状态变为 BLOCKED，当 Object 的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。</p><h3 id="可重入原理：加锁次数计数器"><a href="#可重入原理：加锁次数计数器" class="headerlink" title="可重入原理：加锁次数计数器"></a>可重入原理：加锁次数计数器</h3><p>上面的 demo 中在执行完同步代码块之后紧接着再会去执行一个静态同步方法，而这个方法锁的对象依然就这个类对象，那么这个正在执行的线程还需要获取该锁吗? 答案是不必的，从上图中就可以看出来，执行静态同步方法的时候就只有一条 monitorexit 指令，并没有 monitorenter 获取锁的指令。这就是锁的重入性，即在同一锁程中，线程不需要再次获取同一把锁。</p><p>Synchronized 先天具有重入性。每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一。</p><h3 id="保证可见性的原理：内存模型和happens-before规则"><a href="#保证可见性的原理：内存模型和happens-before规则" class="headerlink" title="保证可见性的原理：内存模型和happens-before规则"></a>保证可见性的原理：内存模型和happens-before规则</h3><p>Synchronized 的 <a href="https://tang7o.cn/2021/10/06/happens-before">happens-before 规则</a>，即监视器锁规则：对同一个监视器的解锁，happens-before 于对该监视器的加锁。继续来看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;     <span class="comment">// 1</span></span><br><span class="line">        a++;                                <span class="comment">// 2</span></span><br><span class="line">    &#125;                                       <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;    <span class="comment">// 4</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a;                         <span class="comment">// 5</span></span><br><span class="line">    &#125;                                      <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码的happens-before关系如图所示：</p><p><img src="3.png" class="lazyload" data-srcset="3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>在图中每一个箭头连接的两个节点就代表之间的 happens-before 关系，黑色的是通过<strong>程序顺序规则</strong>推导出来，红色的为监视器锁规则推导而出：线程 A 释放锁 happens-before 线程 B 加锁，蓝色的则是通过<strong>程序顺序规则</strong>和<strong>监视器锁规则</strong>以及<strong>传递性规则</strong>推测出来 happens-befor 关系。现在我们来重点关注 2 happens-before 5，通过这个关系我们可以得出什么?</p><p>根据 happens-before 的定义中的一条:如果 A happens-before B，则 A 的执行结果对 B 可见，并且 A 的执行顺序先于 B。线程 A 先对共享变量 A 进行加一，由 2 happens-before 5 关系可知线程 A 的执行结果对线程 B 可见即线程 B 所读取到的 a 的值为 1。</p><h2 id="JVM中锁的优化"><a href="#JVM中锁的优化" class="headerlink" title="JVM中锁的优化"></a>JVM中锁的优化</h2><p>简单来说在 JVM 中 monitorenter 和 monitorexit 字节码依赖于底层的操作系统的 Mutex Lock 来实现的，但是由于使用 Mutex Lock 需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的；然而在现实中的大部分情况下，同步方法是运行在单线程环境（无锁竞争环境）如果每次都调用 Mutex Lock 那么将严重的影响程序的性能。<strong>不过在 jdk1.6 中对锁的实现引入了大量的优化，如锁粗化（Lock Coarsening）、锁消除（Lock Elimination）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）、适应性自旋（Adaptive Spinning）等技术来减少锁操作的开销</strong>。</p><ul><li><p><strong>锁粗化（Lock Coarsening）</strong>：也就是减少不必要的紧连在一起的 unlock，lock 操作，将多个连续的锁扩展成一个范围更大的锁。</p></li><li><p><strong>锁消（Lock Elimination）</strong>：通过运行时 JIT 编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本地 Stack 上进行对象空间的分配（同时还可以减少 Heap 上的垃圾收集开销）。</p></li><li><strong>轻量级锁（Lightweight Locking）</strong>：这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态（即单线程执行环境），在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在 monitorenter 和 monitorexit 中只需要依靠一条 CAS 原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒（具体处理步骤下面详细讨论）。</li><li><strong>偏向锁（Biased Locking）</strong>：是为了在无锁竞争的情况下避免在锁获取过程中执行不必要的 CAS 原子指令，因为 CAS 原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟。</li><li><strong>适应性自旋（Adaptive Spinning）</strong>：当线程在获取轻量级锁的过程中执行 CAS 操作失败时，在进入与 monitor 相关联的操作系统重量级锁（mutex semaphore）前会进入忙等待（Spinning）然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用与该 monitor 关联的 semaphore （即互斥锁）进入到阻塞状态。</li></ul><h3 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h3><p>在 Java SE 1.6 里 Synchronied 同步锁，一共有四种状态：<code>无锁</code>、<code>偏向锁</code>、<code>轻量级所</code>、<code>重量级锁</code>，它会随着竞争情况逐渐升级。锁可以升级但是不可以降级，目的是为了提供获取锁和释放锁的效率。</p><blockquote><p>锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁（此过程是不可逆的）</p></blockquote><h3 id="自旋锁与自适应自旋锁"><a href="#自旋锁与自适应自旋锁" class="headerlink" title="自旋锁与自适应自旋锁"></a>自旋锁与自适应自旋锁</h3><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><blockquote><p>引入背景：大家都知道，在没有加入锁优化时，Synchronized 是一个非常“胖大”的家伙。在多线程竞争锁时，当一个线程获取锁时，它会阻塞所有正在竞争的线程，这样对性能带来了极大的影响。在挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作对系统的并发性能带来了很大的压力。同时 HotSpot 团队注意到在很多情况下，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和回复阻塞线程并不值得。在如今多处理器环境下，完全可以让另一个没有获取到锁的线程在门外等待一会（自旋），但不放弃 CPU 的执行时间。等待持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需要让线程执行一个忙循环（自旋），这便是自旋锁由来的原因。</p></blockquote><p>自旋锁早在 JDK1.4 中就引入了，只是当时默认时关闭的。在 JDK 1.6 后默认为开启状态。自旋锁本质上与阻塞并不相同，先不考虑其对多处理器的要求，如果锁占用的时间非常的短，那么自旋锁的新能会非常的好，相反，其会带来更多的性能开销（因为在线程自旋时，始终会占用 CPU 的时间片，如果锁占用的时间太长，那么自旋的线程会白白消耗掉 CPU 资源）。因此自旋等待的时间必须要有一定的限度，如果自选超过了限定的次数仍然没有成功获取到锁，就应该使用传统的方式去挂起线程了，在 JDK 定义中，自旋锁默认的自旋次数为 10 次，用户可以使用参数 <code>-XX:PreBlockSpin</code> 来更改。</p><p>可是现在又出现了一个问题：如果线程锁在线程自旋刚结束就释放掉了锁，那么是不是有点得不偿失。所以这时候我们需要更加聪明的锁来实现更加灵活的自旋。来提高并发的性能。（这里则需要自适应自旋锁！）</p><h4 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h4><p>在 JDK 1.6 中引入了自适应自旋锁。这就意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么 JVM 会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到 100 次循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，JVM对程序的锁的状态预测会越来越准备，JVM也会越来越聪明。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除时指虚拟机即时编译器再运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。意思就是：JVM 会判断再一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那 JVM 就把它们当作栈上数据对待，认为这些数据时线程独有的，不需要加同步。此时就会进行锁消除。</p><p>当然在实际开发中，我们很清楚的知道那些地方时线程独有的，不需要加同步锁，但是在 Java API 中有很多方法都是加了同步的，那么此时 JVM 会判断这段代码是否需要加锁。如果数据并不会逃逸，则会进行锁消除。比如如下操作：在操作 String 类型数据时，由于 String 是一个不可变类，对字符串的连接操作总是通过生成的新的 String 对象来进行的。因此 Javac 编译器会对 String 连接做自动优化。在 JDK 1.5 之前会使用 StringBuffer 对象的连续 <code>append()</code> 操作，在 JDK 1.5 及以后的版本中，会转化为 StringBuidler 对象的连续 <code>append()</code> 操作。</p><p>众所周知，StringBuilder 不是安全同步的，但是在上述代码中， JVM 判断该段代码并不会逃逸，则将该代码带默认为线程独有的资源，并不需要同步，所以执行了锁消除操作。(还有 Vector 中的各种操作也可实现锁消除。在没有逃逸出数据安全防卫内)</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>原则上，我们都知道在加同步锁时，尽可能的将同步块的作用范围限制到尽量小的范围(只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。在存在锁同步竞争中，也可以使得等待锁的线程尽早的拿到锁)。</p><p>大部分上述情况是完美正确的，但是如果存在连串的一系列操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要地性能操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">test04</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述地连续 <code>append()</code> 操作中就属于这类情况。JVM 会检测到这样一连串地操作都是对同一个对象加锁，那么 JVM 会将加锁同步地范围扩展（粗化）到整个一系列操作的 外部，使整个一连串地 <code>append()</code> 操作只需要加锁一次就可以了。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>在 JDK 1.6 之后引入的轻量级锁，需要注意的是轻量级锁并不是替代重量级锁的，而是对在大多数情况下同步块并不会有竞争出现提出的一种优化。它可以减少重量级锁对线程的阻塞带来地线程开销。从而提高并发性能。</p><p>如果要理解轻量级锁，那么必须先要了解 HotSpot 虚拟机中对象头地内存布局。上面介绍 Java 对象头也详细介绍过。在对象头中（<code>Object Header</code>）存在两部分。第一部分用于存储对象自身的运行时数据，<code>HashCode</code>、<code>GC Age</code>、<code>锁标记位</code>、<code>是否为偏向锁</code>等。一般为32位或者64位（视操作系统位数定）。官方称之为 <code>Mark Word</code>，它是实现轻量级锁和偏向锁的关键。 另外一部分存储的是指向方法区对象类型数据的指针（<code>Klass Point</code>），如果对象是数组的话，还会有一个额外的部分用于存储数据的长度。</p><h4 id="轻量级锁加锁"><a href="#轻量级锁加锁" class="headerlink" title="轻量级锁加锁"></a>轻量级锁加锁</h4><p>在线程执行同步块之前，JVM 会先在当前线程的栈帧中创建一个名为锁记录（<code>Lock Record</code>）的空间，用于存储锁对象目前的 <code>Mark Word</code> 的拷贝（JVM 会将对象头中的 <code>Mark Word</code> 拷贝到锁记录中，官方称为 <code>Displaced Mark Ward</code> ）这个时候线程堆栈与对象头的状态如图：</p><p><img src="4.png" class="lazyload" data-srcset="4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>如上图所示：如果当前对象没有被锁定，那么锁标志位位 01 状态，JVM 在执行当前线程时，首先会在当前线程栈帧中创建锁记录 <code>Lock Record</code> 的空间用于存储锁对象目前的 <code>Mark Word</code> 的拷贝。</p><p> 然后，虚拟机使用 CAS 操作将标记字段 Mark Word 拷贝到锁记录中，并且将 <code>Mark Word</code> 更新为指向 <code>Lock Record</code> 的指针。如果更新成功了，那么这个线程就有用了该对象的锁，并且对象 Mark Word 的锁标志位更新为（<code>Mark Word</code> 中最后的 2 bit）00，即表示此对象处于轻量级锁定状态，如图：</p><p><img src="5.png" class="lazyload" data-srcset="5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>如果这个更新操作失败，JVM 会检查当前的 <code>Mark Word</code> 中是否存在指向当前线程的栈帧的指针，如果有，说明该锁已经被获取，可以直接调用。如果没有，则说明该锁被其他线程抢占了，如果有两条以上的线程竞争同一个锁，那轻量级锁就不再有效，直接膨胀位重量级锁，没有获得锁的线程会被阻塞。此时，锁的标志位为 <code>10.Mark Word</code> 中存储的时指向重量级锁的指针。</p><p>轻量级解锁时，会使用原子的 CAS 操作将 <code>Displaced Mark Word</code> 替换回到对象头中，如果成功，则表示没有发生竞争关系。如果失败，表示当前锁存在竞争关系。锁就会膨胀成重量级锁。两个线程同时争夺锁，导致锁膨胀的流程图如下：</p><p><img src="6.png" class="lazyload" data-srcset="6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><blockquote><p>引入背景：在大多实际环境下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，那么在同一个线程反复获取所释放锁中，其中并还没有锁的竞争，那么这样看上去，多次的获取锁和释放锁带来了很多不必要的性能开销和上下文切换。</p></blockquote><p>为了解决这一问题，HotSpot 的作者在 Java SE 1.6 中对 Synchronized 进行了优化，引入了偏向锁。当一个线程访问同步快并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID，以后该线程在进入和推出同步块时不需要进行 CAS 操作来加锁和解锁。只需要简单地测试一下对象头的 <code>Mark Word</code> 里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁。</p><p><img src="7.png" class="lazyload" data-srcset="7.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><h4 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h4><p>偏向锁使用了一种等待竞争出现才会释放锁的机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点（就是当前线程没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，JVM 会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。</p><p><img src="8.png" class="lazyload" data-srcset="8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p><p>著作权归<a href="https://pdai.tech所有。">https://pdai.tech所有。</a> 链接：<a href="https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html">https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html</a></p><h3 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h3><div class="table-container"><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>使用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要 CAS 操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td>适用于只有一个线程访问同步快的场景</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了响应速度</td><td>如线程成始终得不到锁竞争的线程，使用自旋会消耗CPU性能</td><td>追求响应时间，同步快执行速度非常快</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU</td><td>线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗</td><td>追求吞吐量，同步快执行速度较长</td></tr></tbody></table></div><h2 id="Synchronized与Lock"><a href="#Synchronized与Lock" class="headerlink" title="Synchronized与Lock"></a>Synchronized与Lock</h2><h3 id="synchronized的缺陷"><a href="#synchronized的缺陷" class="headerlink" title="synchronized的缺陷"></a>synchronized的缺陷</h3><ul><li><code>效率低</code>：锁的释放情况少，只有代码执行完毕或者异常结束才会释放锁；试图获取锁的时候不能设定超时，不能中断一个正在使用锁的线程，相对而言，Lock 可以中断和设置超时。</li><li><code>不够灵活</code>：加锁和释放的时机单一，每个锁仅有一个单一的条件（某个对象），相对而言，读写锁更加灵活。</li><li><code>无法知道是否成功获得锁</code>，相对而言，Lock可以拿到状态，如果成功获取锁，….，如果获取失败，…..。</li></ul><h3 id="Lock解决相应问题"><a href="#Lock解决相应问题" class="headerlink" title="Lock解决相应问题"></a>Lock解决相应问题</h3><p>Lock 类这里不做过多解释，主要看里面的4个方法:</p><ul><li><code>lock()</code>: 加锁</li><li><code>unlock()</code>: 解锁</li><li><code>tryLock()</code>: 尝试获取锁，返回一个boolean值</li><li><code>tryLock(long,TimeUtil)</code>: 尝试获取锁，可以设置超时</li></ul><p>Synchronized 只有锁只与一个条件（是否获取锁）相关联，不灵活，后来 <code>Condition 与 Lock 的结合</code> 解决了这个问题。</p><p>多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断。高并发的情况下会导致性能下降。ReentrantLock 的lockInterruptibly() 方法可以优先考虑响应中断。 一个线程等待时间过长，它可以中断自己，然后 ReentrantLock 响应这个中断，不再让这个线程继续等待。有了这个机制，使用 ReentrantLock 时就不会像 synchronized 那样产生死锁了。</p><blockquote><p><code>ReentrantLock</code> 为常用类，它是一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。</p></blockquote><h2 id="再深入理解"><a href="#再深入理解" class="headerlink" title="再深入理解"></a>再深入理解</h2><p>synchronized 是通过软件（JVM）实现的，简单易用，即使在 JDK5 之后有了 Lock，仍然被广泛地使用。</p><ul><li><strong>使用 Synchronized 有哪些要注意的？</strong><ul><li>锁对象不能为空，因为锁的信息都保存在对象头里。</li><li>作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错。</li><li>避免死锁。</li><li>在能选择的情况下，既不要用 Lock 也不要用 synchronized 关键字，用 java.util.concurrent 包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用 synchronized 关键，因为代码量少，避免出错。</li></ul></li><li><strong>synchronized 是公平锁吗？</strong></li></ul><p>synchronized 实际上是非公平的，新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待。</p>]]></content>
    
    
    <summary type="html">在 C 程序代码中我们可以利用操作系统提供的互斥锁来实现同步块的互斥访问及线程的阻塞及唤醒等工作。在 Java 中除了提供 Lock API 外还在语法层面上提供了 synchronized 关键字来实现互斥同步原语, 本文将对 synchronized 关键字详细分析。</summary>
    
    
    
    <category term="Java" scheme="https://tang7o.cn/categories/Java/"/>
    
    <category term="并发" scheme="https://tang7o.cn/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="Java" scheme="https://tang7o.cn/tags/Java/"/>
    
    <category term="并发" scheme="https://tang7o.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
